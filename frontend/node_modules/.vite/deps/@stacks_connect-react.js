import {
  $t,
  A,
  AppConfig,
  At,
  BLOCKSTACK_APP_PRIVATE_KEY_LABEL,
  BLOCKSTACK_HANDLER,
  BLOCKSTACK_STORAGE_LABEL,
  Be,
  DEFAULT_BLOCKSTACK_HOST,
  DEFAULT_CORE_NODE,
  DEFAULT_PROFILE,
  DEFAULT_SCOPE,
  Fe,
  G,
  Ht,
  LOCALSTORAGE_SESSION_KEY,
  Mt,
  NAME_LOOKUP_PATH,
  Nt,
  O,
  Ot,
  Qt,
  St,
  U,
  UserSession,
  W,
  Ze,
  Zt,
  _t,
  ct,
  d,
  de,
  decryptPrivateKey,
  doPublicKeysMatchIssuer,
  doSignaturesMatchPublicKeys,
  fe,
  fetchAppManifest,
  g,
  getAddressFromDID,
  getAuthRequestFromURL,
  getDIDType,
  he,
  isExpirationDateValid,
  isIssuanceDateValid,
  isManifestUriValid,
  isRedirectUriValid,
  le,
  lookupProfile,
  makeAuthRequest,
  makeAuthRequestToken,
  makeAuthResponse,
  makeDIDFromAddress,
  makeDIDFromPublicKey,
  pt,
  st,
  ut,
  verifyAuthRequest,
  verifyAuthRequestAndLoadManifest,
  verifyAuthResponse,
  x,
  y,
  yt,
  z,
  ze,
  zt
} from "./chunk-MVRJ52EJ.js";
import "./chunk-SLHBD22L.js";
import "./chunk-S4V27IKT.js";
import {
  require_react
} from "./chunk-QV6VW2LK.js";
import "./chunk-M7CDSSNT.js";
import {
  __toESM
} from "./chunk-HM4MQYWN.js";

// node_modules/@stacks/connect-react/dist/index.mjs
var import_react = __toESM(require_react(), 1);
var w = Object.defineProperty;
var _ = Object.defineProperties;
var I = Object.getOwnPropertyDescriptors;
var O2 = Object.getOwnPropertySymbols;
var E = Object.prototype.hasOwnProperty;
var H = Object.prototype.propertyIsEnumerable;
var S = (n, e, a) => e in n ? w(n, e, { enumerable: true, configurable: true, writable: true, value: a }) : n[e] = a;
var i = (n, e) => {
  for (var a in e || (e = {}))
    E.call(e, a) && S(n, a, e[a]);
  if (O2)
    for (var a of O2(e))
      H.call(e, a) && S(n, a, e[a]);
  return n;
};
var s = (n, e) => _(n, I(e));
var D = { isOpen: false, isAuthenticating: false, authData: void 0, userSession: void 0, authOptions: { redirectTo: "", manifestPath: "", onFinish: () => null, authOrigin: void 0, sendToSignIn: false, appDetails: { name: "", icon: "" } } };
var B = (n, { type: e, payload: a }) => {
  switch (e) {
    case "data/update-auth-options":
      return s(i({}, n), { authOptions: i(i({}, n.authOptions), a) });
    default:
      throw new Error(`Unhandled action type: ${e}`);
  }
};
var c = (0, import_react.createContext)(D);
var d2 = (0, import_react.createContext)(void 0);
var P = ({ authOptions: n, children: e }) => {
  let [a, t] = (0, import_react.useReducer)(B, D);
  return import_react.default.createElement(c.Provider, { value: s(i({}, a), { authOptions: n }) }, import_react.default.createElement(d2.Provider, { value: t }, e));
};
var j = ({ authOptions: n, children: e }) => import_react.default.createElement(P, { authOptions: n }, e);
var W2 = () => {
  let n = (0, import_react.useContext)(d2);
  if (!n)
    throw new Error("This must be used within the ConnectProvider component.");
  return n;
};
var Y = () => {
  let { isOpen: n, isAuthenticating: e, authData: a, authOptions: t, userSession: T } = (0, import_react.useContext)(c), A2 = W2(), m = (o) => A2({ type: "data/update-auth-options", payload: o }), v = (o, r, u) => {
    if (o) {
      let p = s(i(i({}, t), r), { onFinish: (X) => {
        var l;
        (l = t.onFinish) == null || l.call(t, X);
      }, sendToSignIn: true });
      A(p, u);
      return;
    } else
      Ze(s(i({}, t), { sendToSignIn: false }));
    t && m(t);
  }, y2 = (o = {}, r) => {
    A(s(i(i({}, t), o), { onFinish: (u) => {
      var p;
      (p = t.onFinish) == null || p.call(t, u);
    } }), r);
  };
  function R(o, r) {
    return le(s(i({}, o), { authOrigin: t.authOrigin, appDetails: t.appDetails }), r);
  }
  function x2(o, r) {
    return de(s(i({}, o), { authOrigin: t.authOrigin, appDetails: t.appDetails }), r);
  }
  function U2(o, r) {
    return fe(s(i({}, o), { authOrigin: t.authOrigin, appDetails: t.appDetails }), r);
  }
  function k(o, r) {
    return ze(s(i({}, o), { authOrigin: t.authOrigin, appDetails: t.appDetails }), r);
  }
  function q(o, r) {
    return Be(s(i({}, o), { authOrigin: t.authOrigin, appDetails: t.appDetails }), r);
  }
  function F(o, r) {
    return Fe(s(i({}, o), { authOrigin: t.authOrigin, appDetails: t.appDetails }), r);
  }
  function b(o, r) {
    return he(s(i({}, o), { authOrigin: t.authOrigin, appDetails: t.appDetails }), r);
  }
  return { isOpen: n, isAuthenticating: e, authData: a, authOptions: t, userSession: T, doOpenAuth: v, doAuth: y2, authenticate: A, doContractCall: R, doContractDeploy: x2, doSTXTransfer: U2, doProfileUpdate: k, sign: q, signStructuredData: F, signPsbt: b };
};
export {
  AppConfig,
  BLOCKSTACK_APP_PRIVATE_KEY_LABEL,
  BLOCKSTACK_HANDLER,
  BLOCKSTACK_STORAGE_LABEL,
  j as Connect,
  W as ContractCallArgumentType,
  DEFAULT_BLOCKSTACK_HOST,
  DEFAULT_CORE_NODE,
  DEFAULT_PROFILE,
  DEFAULT_SCOPE,
  LOCALSTORAGE_SESSION_KEY,
  NAME_LOOKUP_PATH,
  Mt as SignatureHash,
  G as TransactionTypes,
  UserSession,
  A as authenticate,
  decryptPrivateKey,
  Ht as defaultAuthURL,
  doPublicKeysMatchIssuer,
  doSignaturesMatchPublicKeys,
  fetchAppManifest,
  getAddressFromDID,
  getAuthRequestFromURL,
  getDIDType,
  Nt as getDefaultProfileUpdateRequestOptions,
  yt as getDefaultPsbtRequestOptions,
  O as getDefaultSignatureRequestOptions,
  y as getKeys,
  U as getOrCreateUserSession,
  d as getStacksProvider,
  st as getStxAddress,
  Zt as getUserData,
  x as getUserSession,
  g as hasAppPrivateKey,
  isExpirationDateValid,
  isIssuanceDateValid,
  isManifestUriValid,
  z as isMobile,
  isRedirectUriValid,
  zt as isStacksWalletInstalled,
  lookupProfile,
  makeAuthRequest,
  makeAuthRequestToken,
  makeAuthResponse,
  ct as makeContractCallToken,
  pt as makeContractDeployToken,
  makeDIDFromAddress,
  makeDIDFromPublicKey,
  $t as makeProfileUpdateToken,
  St as makePsbtToken,
  ut as makeSTXTransferToken,
  le as openContractCall,
  de as openContractDeploy,
  ze as openProfileUpdateRequestPopup,
  he as openPsbtRequestPopup,
  fe as openSTXTransfer,
  Be as openSignatureRequestPopup,
  Fe as openStructuredDataSignatureRequestPopup,
  Qt as shouldUsePopup,
  Ze as showBlockstackConnect,
  _t as showConnect,
  Ot as signMessage,
  At as signStructuredMessage,
  Y as useConnect,
  verifyAuthRequest,
  verifyAuthRequestAndLoadManifest,
  verifyAuthResponse
};
//# sourceMappingURL=@stacks_connect-react.js.map
