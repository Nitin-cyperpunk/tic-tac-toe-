import {
  bootstrapLazy,
  promiseResolve
} from "./chunk-SLHBD22L.js";
import {
  ChainID,
  Point,
  deserializeTransaction,
  getAddressFromPublicKey,
  getPublicKey,
  getSharedSecret,
  hmac,
  require_assert,
  require_crypto,
  require_sha2,
  require_sha256,
  require_src,
  require_utils,
  ripemd160,
  serializeCV,
  serializePostCondition,
  sha256,
  sha512,
  signSync,
  utils
} from "./chunk-S4V27IKT.js";
import {
  BLOCKSTACK_DEFAULT_GAIA_HUB_URL,
  BLOCKSTACK_HANDLER,
  FailedDecryptionError,
  InvalidDIDError,
  InvalidStateError,
  Logger,
  LoginFailedError,
  MissingParameterError,
  NoSessionDataError,
  StacksMainnet,
  StacksNetwork,
  StacksTestnet,
  bytesToHex,
  bytesToUtf8,
  concatBytes,
  createFetchFn,
  getGlobalObject,
  hexToBytes,
  isLaterVersion,
  isSameOriginAbsoluteUrl,
  makeUUID4,
  nextHour,
  nextMonth,
  nextYear,
  privateKeyToBytes,
  utf8ToBytes
} from "./chunk-M7CDSSNT.js";
import {
  __commonJS,
  __require,
  __toESM
} from "./chunk-HM4MQYWN.js";

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray2;
    exports.fromByteArray = fromByteArray2;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray2(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray2(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "node_modules/bs58/index.js"(exports, module) {
    var basex = require_src();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module.exports = basex(ALPHABET);
  }
});

// node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/@noble/hashes/hmac.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils();
    var HMAC = class extends utils_js_1.Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        _assert_js_1.default.hash(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new TypeError("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        _assert_js_1.default.exists(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.bytes(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    var hmac2 = (hash, key, message) => new HMAC(hash, key).update(message).digest();
    exports.hmac = hmac2;
    exports.hmac.create = (hash, key) => new HMAC(hash, key);
  }
});

// node_modules/@noble/hashes/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/@noble/hashes/pbkdf2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2Async = exports.pbkdf2 = void 0;
    var _assert_js_1 = require_assert();
    var hmac_js_1 = require_hmac();
    var utils_js_1 = require_utils();
    function pbkdf2Init(hash, _password, _salt, _opts) {
      _assert_js_1.default.hash(hash);
      const opts = (0, utils_js_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
      const { c: c2, dkLen, asyncTick } = opts;
      _assert_js_1.default.number(c2);
      _assert_js_1.default.number(dkLen);
      _assert_js_1.default.number(asyncTick);
      if (c2 < 1)
        throw new Error("PBKDF2: iterations (c) should be >= 1");
      const password = (0, utils_js_1.toBytes)(_password);
      const salt = (0, utils_js_1.toBytes)(_salt);
      const DK = new Uint8Array(dkLen);
      const PRF = hmac_js_1.hmac.create(hash, password);
      const PRFSalt = PRF._cloneInto().update(salt);
      return { c: c2, dkLen, asyncTick, DK, PRF, PRFSalt };
    }
    function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
      PRF.destroy();
      PRFSalt.destroy();
      if (prfW)
        prfW.destroy();
      u.fill(0);
      return DK;
    }
    function pbkdf2(hash, password, salt, opts) {
      const { c: c2, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_js_1.createView)(arr);
      const u = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for (let ui = 1; ui < c2; ui++) {
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i = 0; i < Ti.length; i++)
            Ti[i] ^= u[i];
        }
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    }
    exports.pbkdf2 = pbkdf2;
    async function pbkdf2Async(hash, password, salt, opts) {
      const { c: c2, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_js_1.createView)(arr);
      const u = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, utils_js_1.asyncLoop)(c2 - 1, asyncTick, (i) => {
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i2 = 0; i2 < Ti.length; i2++)
            Ti[i2] ^= u[i2];
        });
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    }
    exports.pbkdf2Async = pbkdf2Async;
  }
});

// node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
    var U32_MASK64 = BigInt(2 ** 32 - 1);
    var _32n = BigInt(32);
    function fromBig(n, le2 = false) {
      if (le2)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    exports.fromBig = fromBig;
    function split(lst, le2 = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le2);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    exports.split = split;
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports.toBig = toBig;
    var shrSH = (h, l, s) => h >>> s;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    var rotr32H = (h, l) => l;
    var rotr32L = (h, l) => h;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    exports.add = add;
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    var u64 = {
      fromBig,
      split,
      toBig: exports.toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports.default = u64;
  }
});

// node_modules/@noble/hashes/sha512.js
var require_sha512 = __commonJS({
  "node_modules/@noble/hashes/sha512.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA512 = void 0;
    var _sha2_js_1 = require_sha2();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils();
    var [SHA512_Kh, SHA512_Kl] = _u64_js_1.default.split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n) => BigInt(n)));
    var SHA512_W_H = new Uint32Array(80);
    var SHA512_W_L = new Uint32Array(80);
    var SHA512 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(128, 64, 16, false);
        this.Ah = 1779033703 | 0;
        this.Al = 4089235720 | 0;
        this.Bh = 3144134277 | 0;
        this.Bl = 2227873595 | 0;
        this.Ch = 1013904242 | 0;
        this.Cl = 4271175723 | 0;
        this.Dh = 2773480762 | 0;
        this.Dl = 1595750129 | 0;
        this.Eh = 1359893119 | 0;
        this.El = 2917565137 | 0;
        this.Fh = 2600822924 | 0;
        this.Fl = 725511199 | 0;
        this.Gh = 528734635 | 0;
        this.Gl = 4215389547 | 0;
        this.Hh = 1541459225 | 0;
        this.Hl = 327033209 | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4) {
          SHA512_W_H[i] = view.getUint32(offset);
          SHA512_W_L[i] = view.getUint32(offset += 4);
        }
        for (let i = 16; i < 80; i++) {
          const W15h = SHA512_W_H[i - 15] | 0;
          const W15l = SHA512_W_L[i - 15] | 0;
          const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
          const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H[i - 2] | 0;
          const W2l = SHA512_W_L[i - 2] | 0;
          const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
          const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
          const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
          const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
          SHA512_W_H[i] = SUMh | 0;
          SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i = 0; i < 80; i++) {
          const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
          const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
          const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
          const T1l = T1ll | 0;
          const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
          const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
          Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
      }
      destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    exports.SHA512 = SHA512;
    var SHA512_224 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 2352822216 | 0;
        this.Al = 424955298 | 0;
        this.Bh = 1944164710 | 0;
        this.Bl = 2312950998 | 0;
        this.Ch = 502970286 | 0;
        this.Cl = 855612546 | 0;
        this.Dh = 1738396948 | 0;
        this.Dl = 1479516111 | 0;
        this.Eh = 258812777 | 0;
        this.El = 2077511080 | 0;
        this.Fh = 2011393907 | 0;
        this.Fl = 79989058 | 0;
        this.Gh = 1067287976 | 0;
        this.Gl = 1780299464 | 0;
        this.Hh = 286451373 | 0;
        this.Hl = 2446758561 | 0;
        this.outputLen = 28;
      }
    };
    var SHA512_256 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 573645204 | 0;
        this.Al = 4230739756 | 0;
        this.Bh = 2673172387 | 0;
        this.Bl = 3360449730 | 0;
        this.Ch = 596883563 | 0;
        this.Cl = 1867755857 | 0;
        this.Dh = 2520282905 | 0;
        this.Dl = 1497426621 | 0;
        this.Eh = 2519219938 | 0;
        this.El = 2827943907 | 0;
        this.Fh = 3193839141 | 0;
        this.Fl = 1401305490 | 0;
        this.Gh = 721525244 | 0;
        this.Gl = 746961066 | 0;
        this.Hh = 246885852 | 0;
        this.Hl = 2177182882 | 0;
        this.outputLen = 32;
      }
    };
    var SHA384 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 3418070365 | 0;
        this.Al = 3238371032 | 0;
        this.Bh = 1654270250 | 0;
        this.Bl = 914150663 | 0;
        this.Ch = 2438529370 | 0;
        this.Cl = 812702999 | 0;
        this.Dh = 355462360 | 0;
        this.Dl = 4144912697 | 0;
        this.Eh = 1731405415 | 0;
        this.El = 4290775857 | 0;
        this.Fh = 2394180231 | 0;
        this.Fl = 1750603025 | 0;
        this.Gh = 3675008525 | 0;
        this.Gl = 1694076839 | 0;
        this.Hh = 1203062813 | 0;
        this.Hl = 3204075428 | 0;
        this.outputLen = 48;
      }
    };
    exports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
    exports.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
    exports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
    exports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
  }
});

// node_modules/@scure/base/lib/index.js
var require_lib = __commonJS({
  "node_modules/@scure/base/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;
    function assertNumber(n) {
      if (!Number.isSafeInteger(n))
        throw new Error(`Wrong integer: ${n}`);
    }
    exports.assertNumber = assertNumber;
    function chain(...args) {
      const wrap = (a2, b2) => (c2) => a2(b2(c2));
      const encode2 = Array.from(args).reverse().reduce((acc, i) => acc ? wrap(acc, i.encode) : i.encode, void 0);
      const decode2 = args.reduce((acc, i) => acc ? wrap(acc, i.decode) : i.decode, void 0);
      return { encode: encode2, decode: decode2 };
    }
    function alphabet(alphabet2) {
      return {
        encode: (digits) => {
          if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
            throw new Error("alphabet.encode input should be an array of numbers");
          return digits.map((i) => {
            assertNumber(i);
            if (i < 0 || i >= alphabet2.length)
              throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet2.length})`);
            return alphabet2[i];
          });
        },
        decode: (input) => {
          if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
            throw new Error("alphabet.decode input should be array of strings");
          return input.map((letter) => {
            if (typeof letter !== "string")
              throw new Error(`alphabet.decode: not string element=${letter}`);
            const index = alphabet2.indexOf(letter);
            if (index === -1)
              throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
            return index;
          });
        }
      };
    }
    function join(separator = "") {
      if (typeof separator !== "string")
        throw new Error("join separator should be string");
      return {
        encode: (from) => {
          if (!Array.isArray(from) || from.length && typeof from[0] !== "string")
            throw new Error("join.encode input should be array of strings");
          for (let i of from)
            if (typeof i !== "string")
              throw new Error(`join.encode: non-string input=${i}`);
          return from.join(separator);
        },
        decode: (to) => {
          if (typeof to !== "string")
            throw new Error("join.decode input should be string");
          return to.split(separator);
        }
      };
    }
    function padding(bits, chr = "=") {
      assertNumber(bits);
      if (typeof chr !== "string")
        throw new Error("padding chr should be string");
      return {
        encode(data) {
          if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
            throw new Error("padding.encode input should be array of strings");
          for (let i of data)
            if (typeof i !== "string")
              throw new Error(`padding.encode: non-string input=${i}`);
          while (data.length * bits % 8)
            data.push(chr);
          return data;
        },
        decode(input) {
          if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
            throw new Error("padding.encode input should be array of strings");
          for (let i of input)
            if (typeof i !== "string")
              throw new Error(`padding.decode: non-string input=${i}`);
          let end = input.length;
          if (end * bits % 8)
            throw new Error("Invalid padding: string should have whole number of bytes");
          for (; end > 0 && input[end - 1] === chr; end--) {
            if (!((end - 1) * bits % 8))
              throw new Error("Invalid padding: string has too much padding");
          }
          return input.slice(0, end);
        }
      };
    }
    function normalize(fn) {
      if (typeof fn !== "function")
        throw new Error("normalize fn should be function");
      return { encode: (from) => from, decode: (to) => fn(to) };
    }
    function convertRadix(data, from, to) {
      if (from < 2)
        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
      if (to < 2)
        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
      if (!Array.isArray(data))
        throw new Error("convertRadix: data should be array");
      if (!data.length)
        return [];
      let pos = 0;
      const res = [];
      const digits = Array.from(data);
      digits.forEach((d2) => {
        assertNumber(d2);
        if (d2 < 0 || d2 >= from)
          throw new Error(`Wrong integer: ${d2}`);
      });
      while (true) {
        let carry = 0;
        let done = true;
        for (let i = pos; i < digits.length; i++) {
          const digit = digits[i];
          const digitBase = from * carry + digit;
          if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
            throw new Error("convertRadix: carry overflow");
          }
          carry = digitBase % to;
          const rounded = Math.floor(digitBase / to);
          digits[i] = rounded;
          if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
            throw new Error("convertRadix: carry overflow");
          if (!done)
            continue;
          else if (!rounded)
            pos = i;
          else
            done = false;
        }
        res.push(carry);
        if (done)
          break;
      }
      for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
        res.push(0);
      return res.reverse();
    }
    var gcd = (a2, b2) => !b2 ? a2 : gcd(b2, a2 % b2);
    var radix2carry = (from, to) => from + (to - gcd(from, to));
    function convertRadix2(data, from, to, padding2) {
      if (!Array.isArray(data))
        throw new Error("convertRadix2: data should be array");
      if (from <= 0 || from > 32)
        throw new Error(`convertRadix2: wrong from=${from}`);
      if (to <= 0 || to > 32)
        throw new Error(`convertRadix2: wrong to=${to}`);
      if (radix2carry(from, to) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
      }
      let carry = 0;
      let pos = 0;
      const mask = 2 ** to - 1;
      const res = [];
      for (const n of data) {
        assertNumber(n);
        if (n >= 2 ** from)
          throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
        carry = carry << from | n;
        if (pos + from > 32)
          throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
        pos += from;
        for (; pos >= to; pos -= to)
          res.push((carry >> pos - to & mask) >>> 0);
        carry &= 2 ** pos - 1;
      }
      carry = carry << to - pos & mask;
      if (!padding2 && pos >= from)
        throw new Error("Excess padding");
      if (!padding2 && carry)
        throw new Error(`Non-zero padding: ${carry}`);
      if (padding2 && pos > 0)
        res.push(carry >>> 0);
      return res;
    }
    function radix(num) {
      assertNumber(num);
      return {
        encode: (bytes) => {
          if (!(bytes instanceof Uint8Array))
            throw new Error("radix.encode input should be Uint8Array");
          return convertRadix(Array.from(bytes), 2 ** 8, num);
        },
        decode: (digits) => {
          if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
            throw new Error("radix.decode input should be array of strings");
          return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
        }
      };
    }
    function radix2(bits, revPadding = false) {
      assertNumber(bits);
      if (bits <= 0 || bits > 32)
        throw new Error("radix2: bits should be in (0..32]");
      if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
        throw new Error("radix2: carry overflow");
      return {
        encode: (bytes) => {
          if (!(bytes instanceof Uint8Array))
            throw new Error("radix2.encode input should be Uint8Array");
          return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
        },
        decode: (digits) => {
          if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
            throw new Error("radix2.decode input should be array of strings");
          return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
        }
      };
    }
    function unsafeWrapper(fn) {
      if (typeof fn !== "function")
        throw new Error("unsafeWrapper fn should be function");
      return function(...args) {
        try {
          return fn.apply(null, args);
        } catch (e) {
        }
      };
    }
    function checksum(len, fn) {
      assertNumber(len);
      if (typeof fn !== "function")
        throw new Error("checksum fn should be function");
      return {
        encode(data) {
          if (!(data instanceof Uint8Array))
            throw new Error("checksum.encode: input should be Uint8Array");
          const checksum2 = fn(data).slice(0, len);
          const res = new Uint8Array(data.length + len);
          res.set(data);
          res.set(checksum2, data.length);
          return res;
        },
        decode(data) {
          if (!(data instanceof Uint8Array))
            throw new Error("checksum.decode: input should be Uint8Array");
          const payload = data.slice(0, -len);
          const newChecksum = fn(payload).slice(0, len);
          const oldChecksum = data.slice(-len);
          for (let i = 0; i < len; i++)
            if (newChecksum[i] !== oldChecksum[i])
              throw new Error("Invalid checksum");
          return payload;
        }
      };
    }
    exports.utils = { alphabet, chain, checksum, radix, radix2, join, padding };
    exports.base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
    exports.base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
    exports.base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
    exports.base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
    exports.base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
    exports.base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
    exports.base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
    var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
    exports.base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    exports.base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
    exports.base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
    var XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
    exports.base58xmr = {
      encode(data) {
        let res = "";
        for (let i = 0; i < data.length; i += 8) {
          const block = data.subarray(i, i + 8);
          res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
        }
        return res;
      },
      decode(str) {
        let res = [];
        for (let i = 0; i < str.length; i += 11) {
          const slice = str.slice(i, i + 11);
          const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
          const block = exports.base58.decode(slice);
          for (let j = 0; j < block.length - blockLen; j++) {
            if (block[j] !== 0)
              throw new Error("base58xmr: wrong padding");
          }
          res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
      }
    };
    var base58check = (sha2562) => chain(checksum(4, (data) => sha2562(sha2562(data))), exports.base58);
    exports.base58check = base58check;
    var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
    var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
    function bech32Polymod(pre) {
      const b2 = pre >> 25;
      let chk = (pre & 33554431) << 5;
      for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
        if ((b2 >> i & 1) === 1)
          chk ^= POLYMOD_GENERATORS[i];
      }
      return chk;
    }
    function bechChecksum(prefix, words, encodingConst = 1) {
      const len = prefix.length;
      let chk = 1;
      for (let i = 0; i < len; i++) {
        const c2 = prefix.charCodeAt(i);
        if (c2 < 33 || c2 > 126)
          throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod(chk) ^ c2 >> 5;
      }
      chk = bech32Polymod(chk);
      for (let i = 0; i < len; i++)
        chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 31;
      for (let v of words)
        chk = bech32Polymod(chk) ^ v;
      for (let i = 0; i < 6; i++)
        chk = bech32Polymod(chk);
      chk ^= encodingConst;
      return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
    }
    function genBech32(encoding) {
      const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
      const _words = radix2(5);
      const fromWords = _words.decode;
      const toWords = _words.encode;
      const fromWordsUnsafe = unsafeWrapper(fromWords);
      function encode2(prefix, words, limit = 90) {
        if (typeof prefix !== "string")
          throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
        if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
          throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
        const actualLength = prefix.length + 7 + words.length;
        if (limit !== false && actualLength > limit)
          throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        const lowered = prefix.toLowerCase();
        const sum = bechChecksum(lowered, words, ENCODING_CONST);
        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
      }
      function decode2(str, limit = 90) {
        if (typeof str !== "string")
          throw new Error(`bech32.decode input should be string, not ${typeof str}`);
        if (str.length < 8 || limit !== false && str.length > limit)
          throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase())
          throw new Error(`String must be lowercase or uppercase`);
        str = lowered;
        const sepIndex = str.lastIndexOf("1");
        if (sepIndex === 0 || sepIndex === -1)
          throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix = str.slice(0, sepIndex);
        const _words2 = str.slice(sepIndex + 1);
        if (_words2.length < 6)
          throw new Error("Data must be at least 6 characters long");
        const words = BECH_ALPHABET.decode(_words2).slice(0, -6);
        const sum = bechChecksum(prefix, words, ENCODING_CONST);
        if (!_words2.endsWith(sum))
          throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return { prefix, words };
      }
      const decodeUnsafe = unsafeWrapper(decode2);
      function decodeToBytes(str) {
        const { prefix, words } = decode2(str, false);
        return { prefix, words, bytes: fromWords(words) };
      }
      return { encode: encode2, decode: decode2, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
    }
    exports.bech32 = genBech32("bech32");
    exports.bech32m = genBech32("bech32m");
    exports.utf8 = {
      encode: (data) => new TextDecoder().decode(data),
      decode: (str) => new TextEncoder().encode(str)
    };
    exports.hex = chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s) => {
      if (typeof s !== "string" || s.length % 2)
        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
      return s.toLowerCase();
    }));
    var CODERS = {
      utf8: exports.utf8,
      hex: exports.hex,
      base16: exports.base16,
      base32: exports.base32,
      base64: exports.base64,
      base64url: exports.base64url,
      base58: exports.base58,
      base58xmr: exports.base58xmr
    };
    var coderTypeError = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr";
    var bytesToString = (type, bytes) => {
      if (typeof type !== "string" || !CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
      if (!(bytes instanceof Uint8Array))
        throw new TypeError("bytesToString() expects Uint8Array");
      return CODERS[type].encode(bytes);
    };
    exports.bytesToString = bytesToString;
    exports.str = exports.bytesToString;
    var stringToBytes = (type, str) => {
      if (!CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
      if (typeof str !== "string")
        throw new TypeError("stringToBytes() expects string");
      return CODERS[type].decode(str);
    };
    exports.stringToBytes = stringToBytes;
    exports.bytes = exports.stringToBytes;
  }
});

// node_modules/@scure/bip39/index.js
var require_bip39 = __commonJS({
  "node_modules/@scure/bip39/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mnemonicToSeedSync = exports.mnemonicToSeed = exports.validateMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.generateMnemonic = void 0;
    var _assert_1 = require_assert();
    var pbkdf2_1 = require_pbkdf2();
    var sha256_1 = require_sha256();
    var sha512_1 = require_sha512();
    var utils_1 = require_utils();
    var base_1 = require_lib();
    var isJapanese = (wordlist2) => wordlist2[0] === "あいこくしん";
    function nfkd(str) {
      if (typeof str !== "string")
        throw new TypeError(`Invalid mnemonic type: ${typeof str}`);
      return str.normalize("NFKD");
    }
    function normalize(str) {
      const norm = nfkd(str);
      const words = norm.split(" ");
      if (![12, 15, 18, 21, 24].includes(words.length))
        throw new Error("Invalid mnemonic");
      return { nfkd: norm, words };
    }
    function assertEntropy(entropy) {
      _assert_1.default.bytes(entropy, 16, 20, 24, 28, 32);
    }
    function generateMnemonic(wordlist2, strength = 128) {
      _assert_1.default.number(strength);
      if (strength % 32 !== 0 || strength > 256)
        throw new TypeError("Invalid entropy");
      return entropyToMnemonic2((0, utils_1.randomBytes)(strength / 8), wordlist2);
    }
    exports.generateMnemonic = generateMnemonic;
    var calcChecksum = (entropy) => {
      const bitsLeft = 8 - entropy.length / 4;
      return new Uint8Array([(0, sha256_1.sha256)(entropy)[0] >> bitsLeft << bitsLeft]);
    };
    function getCoder(wordlist2) {
      if (!Array.isArray(wordlist2) || wordlist2.length !== 2 ** 11 || typeof wordlist2[0] !== "string")
        throw new Error("Worlist: expected array of 2048 strings");
      wordlist2.forEach((i) => {
        if (typeof i !== "string")
          throw new Error(`Wordlist: non-string element: ${i}`);
      });
      return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist2));
    }
    function mnemonicToEntropy2(mnemonic, wordlist2) {
      const { words } = normalize(mnemonic);
      const entropy = getCoder(wordlist2).decode(words);
      assertEntropy(entropy);
      return entropy;
    }
    exports.mnemonicToEntropy = mnemonicToEntropy2;
    function entropyToMnemonic2(entropy, wordlist2) {
      assertEntropy(entropy);
      const words = getCoder(wordlist2).encode(entropy);
      return words.join(isJapanese(wordlist2) ? "　" : " ");
    }
    exports.entropyToMnemonic = entropyToMnemonic2;
    function validateMnemonic2(mnemonic, wordlist2) {
      try {
        mnemonicToEntropy2(mnemonic, wordlist2);
      } catch (e) {
        return false;
      }
      return true;
    }
    exports.validateMnemonic = validateMnemonic2;
    var salt = (passphrase) => nfkd(`mnemonic${passphrase}`);
    function mnemonicToSeed(mnemonic, passphrase = "") {
      return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
    }
    exports.mnemonicToSeed = mnemonicToSeed;
    function mnemonicToSeedSync(mnemonic, passphrase = "") {
      return (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
    }
    exports.mnemonicToSeedSync = mnemonicToSeedSync;
  }
});

// node_modules/@scure/bip39/wordlists/english.js
var require_english = __commonJS({
  "node_modules/@scure/bip39/wordlists/english.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wordlist = void 0;
    exports.wordlist = `abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo`.split("\n");
  }
});

// node_modules/jsontokens/lib/base64Url.js
var require_base64Url = __commonJS({
  "node_modules/jsontokens/lib/base64Url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decode = exports.encode = exports.unescape = exports.escape = exports.pad = void 0;
    var base64_js_1 = require_base64_js();
    function pad(base64) {
      return `${base64}${"=".repeat(4 - (base64.length % 4 || 4))}`;
    }
    exports.pad = pad;
    function escape(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    exports.escape = escape;
    function unescape(base64Url) {
      return pad(base64Url).replace(/-/g, "+").replace(/_/g, "/");
    }
    exports.unescape = unescape;
    function encode2(base64) {
      return escape((0, base64_js_1.fromByteArray)(new TextEncoder().encode(base64)));
    }
    exports.encode = encode2;
    function decode2(base64Url) {
      return new TextDecoder().decode((0, base64_js_1.toByteArray)(pad(unescape(base64Url))));
    }
    exports.decode = decode2;
  }
});

// node_modules/@noble/secp256k1/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@noble/secp256k1/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utils = exports.schnorr = exports.verify = exports.signSync = exports.sign = exports.getSharedSecret = exports.recoverPublicKey = exports.getPublicKey = exports.Signature = exports.Point = exports.CURVE = void 0;
    var nodeCrypto = require_crypto();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _8n = BigInt(8);
    var CURVE = Object.freeze({
      a: _0n,
      b: BigInt(7),
      P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
      n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
      h: _1n,
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
    });
    exports.CURVE = CURVE;
    var divNearest = (a2, b2) => (a2 + b2 / _2n) / b2;
    var endo = {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar(k2) {
        const { n } = CURVE;
        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
        const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
        const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
        const b2 = a1;
        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
        const c1 = divNearest(b2 * k2, n);
        const c2 = divNearest(-b1 * k2, n);
        let k1 = mod(k2 - c1 * a1 - c2 * a2, n);
        let k22 = mod(-c1 * b1 - c2 * b2, n);
        const k1neg = k1 > POW_2_128;
        const k2neg = k22 > POW_2_128;
        if (k1neg)
          k1 = n - k1;
        if (k2neg)
          k22 = n - k22;
        if (k1 > POW_2_128 || k22 > POW_2_128) {
          throw new Error("splitScalarEndo: Endomorphism failed, k=" + k2);
        }
        return { k1neg, k1, k2neg, k2: k22 };
      }
    };
    var fieldLen = 32;
    var groupLen = 32;
    var hashLen = 32;
    var compressedLen = fieldLen + 1;
    var uncompressedLen = 2 * fieldLen + 1;
    function weierstrass(x2) {
      const { a: a2, b: b2 } = CURVE;
      const x22 = mod(x2 * x2);
      const x3 = mod(x22 * x2);
      return mod(x3 + a2 * x2 + b2);
    }
    var USE_ENDOMORPHISM = CURVE.a === _0n;
    var ShaError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    function assertJacPoint(other) {
      if (!(other instanceof JacobianPoint))
        throw new TypeError("JacobianPoint expected");
    }
    var JacobianPoint = class _JacobianPoint {
      constructor(x2, y2, z2) {
        this.x = x2;
        this.y = y2;
        this.z = z2;
      }
      static fromAffine(p) {
        if (!(p instanceof Point2)) {
          throw new TypeError("JacobianPoint#fromAffine: expected Point");
        }
        if (p.equals(Point2.ZERO))
          return _JacobianPoint.ZERO;
        return new _JacobianPoint(p.x, p.y, _1n);
      }
      static toAffineBatch(points) {
        const toInv = invertBatch(points.map((p) => p.z));
        return points.map((p, i) => p.toAffine(toInv[i]));
      }
      static normalizeZ(points) {
        return _JacobianPoint.toAffineBatch(points).map(_JacobianPoint.fromAffine);
      }
      equals(other) {
        assertJacPoint(other);
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        const Z1Z1 = mod(Z1 * Z1);
        const Z2Z2 = mod(Z2 * Z2);
        const U1 = mod(X1 * Z2Z2);
        const U2 = mod(X2 * Z1Z1);
        const S1 = mod(mod(Y1 * Z2) * Z2Z2);
        const S2 = mod(mod(Y2 * Z1) * Z1Z1);
        return U1 === U2 && S1 === S2;
      }
      negate() {
        return new _JacobianPoint(this.x, mod(-this.y), this.z);
      }
      double() {
        const { x: X1, y: Y1, z: Z1 } = this;
        const A2 = mod(X1 * X1);
        const B2 = mod(Y1 * Y1);
        const C2 = mod(B2 * B2);
        const x1b = X1 + B2;
        const D2 = mod(_2n * (mod(x1b * x1b) - A2 - C2));
        const E2 = mod(_3n * A2);
        const F = mod(E2 * E2);
        const X3 = mod(F - _2n * D2);
        const Y3 = mod(E2 * (D2 - X3) - _8n * C2);
        const Z3 = mod(_2n * Y1 * Z1);
        return new _JacobianPoint(X3, Y3, Z3);
      }
      add(other) {
        assertJacPoint(other);
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        if (X2 === _0n || Y2 === _0n)
          return this;
        if (X1 === _0n || Y1 === _0n)
          return other;
        const Z1Z1 = mod(Z1 * Z1);
        const Z2Z2 = mod(Z2 * Z2);
        const U1 = mod(X1 * Z2Z2);
        const U2 = mod(X2 * Z1Z1);
        const S1 = mod(mod(Y1 * Z2) * Z2Z2);
        const S2 = mod(mod(Y2 * Z1) * Z1Z1);
        const H = mod(U2 - U1);
        const r = mod(S2 - S1);
        if (H === _0n) {
          if (r === _0n) {
            return this.double();
          } else {
            return _JacobianPoint.ZERO;
          }
        }
        const HH = mod(H * H);
        const HHH = mod(H * HH);
        const V = mod(U1 * HH);
        const X3 = mod(r * r - HHH - _2n * V);
        const Y3 = mod(r * (V - X3) - S1 * HHH);
        const Z3 = mod(Z1 * Z2 * H);
        return new _JacobianPoint(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      multiplyUnsafe(scalar) {
        const P0 = _JacobianPoint.ZERO;
        if (typeof scalar === "bigint" && scalar === _0n)
          return P0;
        let n = normalizeScalar(scalar);
        if (n === _1n)
          return this;
        if (!USE_ENDOMORPHISM) {
          let p = P0;
          let d3 = this;
          while (n > _0n) {
            if (n & _1n)
              p = p.add(d3);
            d3 = d3.double();
            n >>= _1n;
          }
          return p;
        }
        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let k1p = P0;
        let k2p = P0;
        let d2 = this;
        while (k1 > _0n || k2 > _0n) {
          if (k1 & _1n)
            k1p = k1p.add(d2);
          if (k2 & _1n)
            k2p = k2p.add(d2);
          d2 = d2.double();
          k1 >>= _1n;
          k2 >>= _1n;
        }
        if (k1neg)
          k1p = k1p.negate();
        if (k2neg)
          k2p = k2p.negate();
        k2p = new _JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
        return k1p.add(k2p);
      }
      precomputeWindow(W2) {
        const windows = USE_ENDOMORPHISM ? 128 / W2 + 1 : 256 / W2 + 1;
        const points = [];
        let p = this;
        let base = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base = p;
          points.push(base);
          for (let i = 1; i < 2 ** (W2 - 1); i++) {
            base = base.add(p);
            points.push(base);
          }
          p = base.double();
        }
        return points;
      }
      wNAF(n, affinePoint) {
        if (!affinePoint && this.equals(_JacobianPoint.BASE))
          affinePoint = Point2.BASE;
        const W2 = affinePoint && affinePoint._WINDOW_SIZE || 1;
        if (256 % W2) {
          throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
        }
        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
        if (!precomputes) {
          precomputes = this.precomputeWindow(W2);
          if (affinePoint && W2 !== 1) {
            precomputes = _JacobianPoint.normalizeZ(precomputes);
            pointPrecomputes.set(affinePoint, precomputes);
          }
        }
        let p = _JacobianPoint.ZERO;
        let f2 = _JacobianPoint.BASE;
        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W2 : 256 / W2);
        const windowSize = 2 ** (W2 - 1);
        const mask = BigInt(2 ** W2 - 1);
        const maxNumber = 2 ** W2;
        const shiftBy = BigInt(W2);
        for (let window2 = 0; window2 < windows; window2++) {
          const offset = window2 * windowSize;
          let wbits = Number(n & mask);
          n >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n += _1n;
          }
          const offset1 = offset;
          const offset2 = offset + Math.abs(wbits) - 1;
          const cond1 = window2 % 2 !== 0;
          const cond2 = wbits < 0;
          if (wbits === 0) {
            f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
          } else {
            p = p.add(constTimeNegate(cond2, precomputes[offset2]));
          }
        }
        return { p, f: f2 };
      }
      multiply(scalar, affinePoint) {
        let n = normalizeScalar(scalar);
        let point;
        let fake;
        if (USE_ENDOMORPHISM) {
          const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
          let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
          let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
          k1p = constTimeNegate(k1neg, k1p);
          k2p = constTimeNegate(k2neg, k2p);
          k2p = new _JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
          point = k1p.add(k2p);
          fake = f1p.add(f2p);
        } else {
          const { p, f: f2 } = this.wNAF(n, affinePoint);
          point = p;
          fake = f2;
        }
        return _JacobianPoint.normalizeZ([point, fake])[0];
      }
      toAffine(invZ) {
        const { x: x2, y: y2, z: z2 } = this;
        const is0 = this.equals(_JacobianPoint.ZERO);
        if (invZ == null)
          invZ = is0 ? _8n : invert(z2);
        const iz1 = invZ;
        const iz2 = mod(iz1 * iz1);
        const iz3 = mod(iz2 * iz1);
        const ax = mod(x2 * iz2);
        const ay = mod(y2 * iz3);
        const zz = mod(z2 * iz1);
        if (is0)
          return Point2.ZERO;
        if (zz !== _1n)
          throw new Error("invZ was invalid");
        return new Point2(ax, ay);
      }
    };
    JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
    JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);
    function constTimeNegate(condition, item) {
      const neg = item.negate();
      return condition ? neg : item;
    }
    var pointPrecomputes = /* @__PURE__ */ new WeakMap();
    var Point2 = class _Point {
      constructor(x2, y2) {
        this.x = x2;
        this.y = y2;
      }
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
      }
      hasEvenY() {
        return this.y % _2n === _0n;
      }
      static fromCompressedHex(bytes) {
        const isShort = bytes.length === 32;
        const x2 = bytesToNumber(isShort ? bytes : bytes.subarray(1));
        if (!isValidFieldElement(x2))
          throw new Error("Point is not on curve");
        const y2 = weierstrass(x2);
        let y3 = sqrtMod(y2);
        const isYOdd = (y3 & _1n) === _1n;
        if (isShort) {
          if (isYOdd)
            y3 = mod(-y3);
        } else {
          const isFirstByteOdd = (bytes[0] & 1) === 1;
          if (isFirstByteOdd !== isYOdd)
            y3 = mod(-y3);
        }
        const point = new _Point(x2, y3);
        point.assertValidity();
        return point;
      }
      static fromUncompressedHex(bytes) {
        const x2 = bytesToNumber(bytes.subarray(1, fieldLen + 1));
        const y2 = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));
        const point = new _Point(x2, y2);
        point.assertValidity();
        return point;
      }
      static fromHex(hex) {
        const bytes = ensureBytes(hex);
        const len = bytes.length;
        const header = bytes[0];
        if (len === fieldLen)
          return this.fromCompressedHex(bytes);
        if (len === compressedLen && (header === 2 || header === 3)) {
          return this.fromCompressedHex(bytes);
        }
        if (len === uncompressedLen && header === 4)
          return this.fromUncompressedHex(bytes);
        throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);
      }
      static fromPrivateKey(privateKey) {
        return _Point.BASE.multiply(normalizePrivateKey(privateKey));
      }
      static fromSignature(msgHash, signature, recovery) {
        const { r, s } = normalizeSignature(signature);
        if (![0, 1, 2, 3].includes(recovery))
          throw new Error("Cannot recover: invalid recovery bit");
        const h = truncateHash(ensureBytes(msgHash));
        const { n } = CURVE;
        const radj = recovery === 2 || recovery === 3 ? r + n : r;
        const rinv = invert(radj, n);
        const u1 = mod(-h * rinv, n);
        const u2 = mod(s * rinv, n);
        const prefix = recovery & 1 ? "03" : "02";
        const R2 = _Point.fromHex(prefix + numTo32bStr(radj));
        const Q = _Point.BASE.multiplyAndAddUnsafe(R2, u1, u2);
        if (!Q)
          throw new Error("Cannot recover signature: point at infinify");
        Q.assertValidity();
        return Q;
      }
      toRawBytes(isCompressed = false) {
        return hexToBytes2(this.toHex(isCompressed));
      }
      toHex(isCompressed = false) {
        const x2 = numTo32bStr(this.x);
        if (isCompressed) {
          const prefix = this.hasEvenY() ? "02" : "03";
          return `${prefix}${x2}`;
        } else {
          return `04${x2}${numTo32bStr(this.y)}`;
        }
      }
      toHexX() {
        return this.toHex(true).slice(2);
      }
      toRawX() {
        return this.toRawBytes(true).slice(1);
      }
      assertValidity() {
        const msg = "Point is not on elliptic curve";
        const { x: x2, y: y2 } = this;
        if (!isValidFieldElement(x2) || !isValidFieldElement(y2))
          throw new Error(msg);
        const left = mod(y2 * y2);
        const right = weierstrass(x2);
        if (mod(left - right) !== _0n)
          throw new Error(msg);
      }
      equals(other) {
        return this.x === other.x && this.y === other.y;
      }
      negate() {
        return new _Point(this.x, mod(-this.y));
      }
      double() {
        return JacobianPoint.fromAffine(this).double().toAffine();
      }
      add(other) {
        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
      }
      subtract(other) {
        return this.add(other.negate());
      }
      multiply(scalar) {
        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
      }
      multiplyAndAddUnsafe(Q, a2, b2) {
        const P = JacobianPoint.fromAffine(this);
        const aP = a2 === _0n || a2 === _1n || this !== _Point.BASE ? P.multiplyUnsafe(a2) : P.multiply(a2);
        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b2);
        const sum = aP.add(bQ);
        return sum.equals(JacobianPoint.ZERO) ? void 0 : sum.toAffine();
      }
    };
    exports.Point = Point2;
    Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy);
    Point2.ZERO = new Point2(_0n, _0n);
    function sliceDER(s) {
      return Number.parseInt(s[0], 16) >= 8 ? "00" + s : s;
    }
    function parseDERInt(data) {
      if (data.length < 2 || data[0] !== 2) {
        throw new Error(`Invalid signature integer tag: ${bytesToHex2(data)}`);
      }
      const len = data[1];
      const res = data.subarray(2, len + 2);
      if (!len || res.length !== len) {
        throw new Error(`Invalid signature integer: wrong length`);
      }
      if (res[0] === 0 && res[1] <= 127) {
        throw new Error("Invalid signature integer: trailing length");
      }
      return { data: bytesToNumber(res), left: data.subarray(len + 2) };
    }
    function parseDERSignature(data) {
      if (data.length < 2 || data[0] != 48) {
        throw new Error(`Invalid signature tag: ${bytesToHex2(data)}`);
      }
      if (data[1] !== data.length - 2) {
        throw new Error("Invalid signature: incorrect length");
      }
      const { data: r, left: sBytes } = parseDERInt(data.subarray(2));
      const { data: s, left: rBytesLeft } = parseDERInt(sBytes);
      if (rBytesLeft.length) {
        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex2(rBytesLeft)}`);
      }
      return { r, s };
    }
    var Signature2 = class _Signature {
      constructor(r, s) {
        this.r = r;
        this.s = s;
        this.assertValidity();
      }
      static fromCompact(hex) {
        const arr = hex instanceof Uint8Array;
        const name = "Signature.fromCompact";
        if (typeof hex !== "string" && !arr)
          throw new TypeError(`${name}: Expected string or Uint8Array`);
        const str = arr ? bytesToHex2(hex) : hex;
        if (str.length !== 128)
          throw new Error(`${name}: Expected 64-byte hex`);
        return new _Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
      }
      static fromDER(hex) {
        const arr = hex instanceof Uint8Array;
        if (typeof hex !== "string" && !arr)
          throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
        const { r, s } = parseDERSignature(arr ? hex : hexToBytes2(hex));
        return new _Signature(r, s);
      }
      static fromHex(hex) {
        return this.fromDER(hex);
      }
      assertValidity() {
        const { r, s } = this;
        if (!isWithinCurveOrder(r))
          throw new Error("Invalid Signature: r must be 0 < r < n");
        if (!isWithinCurveOrder(s))
          throw new Error("Invalid Signature: s must be 0 < s < n");
      }
      hasHighS() {
        const HALF = CURVE.n >> _1n;
        return this.s > HALF;
      }
      normalizeS() {
        return this.hasHighS() ? new _Signature(this.r, mod(-this.s, CURVE.n)) : this;
      }
      toDERRawBytes() {
        return hexToBytes2(this.toDERHex());
      }
      toDERHex() {
        const sHex = sliceDER(numberToHexUnpadded(this.s));
        const rHex = sliceDER(numberToHexUnpadded(this.r));
        const sHexL = sHex.length / 2;
        const rHexL = rHex.length / 2;
        const sLen = numberToHexUnpadded(sHexL);
        const rLen = numberToHexUnpadded(rHexL);
        const length = numberToHexUnpadded(rHexL + sHexL + 4);
        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;
      }
      toRawBytes() {
        return this.toDERRawBytes();
      }
      toHex() {
        return this.toDERHex();
      }
      toCompactRawBytes() {
        return hexToBytes2(this.toCompactHex());
      }
      toCompactHex() {
        return numTo32bStr(this.r) + numTo32bStr(this.s);
      }
    };
    exports.Signature = Signature2;
    function concatBytes2(...arrays) {
      if (!arrays.every((b2) => b2 instanceof Uint8Array))
        throw new Error("Uint8Array list expected");
      if (arrays.length === 1)
        return arrays[0];
      const length = arrays.reduce((a2, arr) => a2 + arr.length, 0);
      const result = new Uint8Array(length);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
      }
      return result;
    }
    var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex2(uint8a) {
      if (!(uint8a instanceof Uint8Array))
        throw new Error("Expected Uint8Array");
      let hex = "";
      for (let i = 0; i < uint8a.length; i++) {
        hex += hexes[uint8a[i]];
      }
      return hex;
    }
    var POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
    function numTo32bStr(num) {
      if (typeof num !== "bigint")
        throw new Error("Expected bigint");
      if (!(_0n <= num && num < POW_2_256))
        throw new Error("Expected number 0 <= n < 2^256");
      return num.toString(16).padStart(64, "0");
    }
    function numTo32b(num) {
      const b2 = hexToBytes2(numTo32bStr(num));
      if (b2.length !== 32)
        throw new Error("Error: expected 32 bytes");
      return b2;
    }
    function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    }
    function hexToNumber(hex) {
      if (typeof hex !== "string") {
        throw new TypeError("hexToNumber: expected string, got " + typeof hex);
      }
      return BigInt(`0x${hex}`);
    }
    function hexToBytes2(hex) {
      if (typeof hex !== "string") {
        throw new TypeError("hexToBytes: expected string, got " + typeof hex);
      }
      if (hex.length % 2)
        throw new Error("hexToBytes: received invalid unpadded hex" + hex.length);
      const array = new Uint8Array(hex.length / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i] = byte;
      }
      return array;
    }
    function bytesToNumber(bytes) {
      return hexToNumber(bytesToHex2(bytes));
    }
    function ensureBytes(hex) {
      return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes2(hex);
    }
    function normalizeScalar(num) {
      if (typeof num === "number" && Number.isSafeInteger(num) && num > 0)
        return BigInt(num);
      if (typeof num === "bigint" && isWithinCurveOrder(num))
        return num;
      throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
    }
    function mod(a2, b2 = CURVE.P) {
      const result = a2 % b2;
      return result >= _0n ? result : b2 + result;
    }
    function pow2(x2, power) {
      const { P } = CURVE;
      let res = x2;
      while (power-- > _0n) {
        res *= res;
        res %= P;
      }
      return res;
    }
    function sqrtMod(x2) {
      const { P } = CURVE;
      const _6n = BigInt(6);
      const _11n = BigInt(11);
      const _22n = BigInt(22);
      const _23n = BigInt(23);
      const _44n = BigInt(44);
      const _88n = BigInt(88);
      const b2 = x2 * x2 * x2 % P;
      const b3 = b2 * b2 * x2 % P;
      const b6 = pow2(b3, _3n) * b3 % P;
      const b9 = pow2(b6, _3n) * b3 % P;
      const b11 = pow2(b9, _2n) * b2 % P;
      const b22 = pow2(b11, _11n) * b11 % P;
      const b44 = pow2(b22, _22n) * b22 % P;
      const b88 = pow2(b44, _44n) * b44 % P;
      const b176 = pow2(b88, _88n) * b88 % P;
      const b220 = pow2(b176, _44n) * b44 % P;
      const b223 = pow2(b220, _3n) * b3 % P;
      const t1 = pow2(b223, _23n) * b22 % P;
      const t2 = pow2(t1, _6n) * b2 % P;
      const rt = pow2(t2, _2n);
      const xc = rt * rt % P;
      if (xc !== x2)
        throw new Error("Cannot find square root");
      return rt;
    }
    function invert(number, modulo = CURVE.P) {
      if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
      }
      let a2 = mod(number, modulo);
      let b2 = modulo;
      let x2 = _0n, y2 = _1n, u = _1n, v = _0n;
      while (a2 !== _0n) {
        const q = b2 / a2;
        const r = b2 % a2;
        const m2 = x2 - u * q;
        const n = y2 - v * q;
        b2 = a2, a2 = r, x2 = u, y2 = v, u = m2, v = n;
      }
      const gcd = b2;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod(x2, modulo);
    }
    function invertBatch(nums, p = CURVE.P) {
      const scratch = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num, i) => {
        if (num === _0n)
          return acc;
        scratch[i] = acc;
        return mod(acc * num, p);
      }, _1n);
      const inverted = invert(lastMultiplied, p);
      nums.reduceRight((acc, num, i) => {
        if (num === _0n)
          return acc;
        scratch[i] = mod(acc * scratch[i], p);
        return mod(acc * num, p);
      }, inverted);
      return scratch;
    }
    function bits2int_2(bytes) {
      const delta = bytes.length * 8 - groupLen * 8;
      const num = bytesToNumber(bytes);
      return delta > 0 ? num >> BigInt(delta) : num;
    }
    function truncateHash(hash, truncateOnly = false) {
      const h = bits2int_2(hash);
      if (truncateOnly)
        return h;
      const { n } = CURVE;
      return h >= n ? h - n : h;
    }
    var _sha256Sync;
    var _hmacSha256Sync;
    var HmacDrbg = class {
      constructor(hashLen2, qByteLen) {
        this.hashLen = hashLen2;
        this.qByteLen = qByteLen;
        if (typeof hashLen2 !== "number" || hashLen2 < 2)
          throw new Error("hashLen must be a number");
        if (typeof qByteLen !== "number" || qByteLen < 2)
          throw new Error("qByteLen must be a number");
        this.v = new Uint8Array(hashLen2).fill(1);
        this.k = new Uint8Array(hashLen2).fill(0);
        this.counter = 0;
      }
      hmac(...values) {
        return exports.utils.hmacSha256(this.k, ...values);
      }
      hmacSync(...values) {
        return _hmacSha256Sync(this.k, ...values);
      }
      checkSync() {
        if (typeof _hmacSha256Sync !== "function")
          throw new ShaError("hmacSha256Sync needs to be set");
      }
      incr() {
        if (this.counter >= 1e3)
          throw new Error("Tried 1,000 k values for sign(), all were invalid");
        this.counter += 1;
      }
      async reseed(seed = new Uint8Array()) {
        this.k = await this.hmac(this.v, Uint8Array.from([0]), seed);
        this.v = await this.hmac(this.v);
        if (seed.length === 0)
          return;
        this.k = await this.hmac(this.v, Uint8Array.from([1]), seed);
        this.v = await this.hmac(this.v);
      }
      reseedSync(seed = new Uint8Array()) {
        this.checkSync();
        this.k = this.hmacSync(this.v, Uint8Array.from([0]), seed);
        this.v = this.hmacSync(this.v);
        if (seed.length === 0)
          return;
        this.k = this.hmacSync(this.v, Uint8Array.from([1]), seed);
        this.v = this.hmacSync(this.v);
      }
      async generate() {
        this.incr();
        let len = 0;
        const out = [];
        while (len < this.qByteLen) {
          this.v = await this.hmac(this.v);
          const sl = this.v.slice();
          out.push(sl);
          len += this.v.length;
        }
        return concatBytes2(...out);
      }
      generateSync() {
        this.checkSync();
        this.incr();
        let len = 0;
        const out = [];
        while (len < this.qByteLen) {
          this.v = this.hmacSync(this.v);
          const sl = this.v.slice();
          out.push(sl);
          len += this.v.length;
        }
        return concatBytes2(...out);
      }
    };
    function isWithinCurveOrder(num) {
      return _0n < num && num < CURVE.n;
    }
    function isValidFieldElement(num) {
      return _0n < num && num < CURVE.P;
    }
    function kmdToSig(kBytes, m2, d2, lowS = true) {
      const { n } = CURVE;
      const k2 = truncateHash(kBytes, true);
      if (!isWithinCurveOrder(k2))
        return;
      const kinv = invert(k2, n);
      const q = Point2.BASE.multiply(k2);
      const r = mod(q.x, n);
      if (r === _0n)
        return;
      const s = mod(kinv * mod(m2 + d2 * r, n), n);
      if (s === _0n)
        return;
      let sig = new Signature2(r, s);
      let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);
      if (lowS && sig.hasHighS()) {
        sig = sig.normalizeS();
        recovery ^= 1;
      }
      return { sig, recovery };
    }
    function normalizePrivateKey(key) {
      let num;
      if (typeof key === "bigint") {
        num = key;
      } else if (typeof key === "number" && Number.isSafeInteger(key) && key > 0) {
        num = BigInt(key);
      } else if (typeof key === "string") {
        if (key.length !== 2 * groupLen)
          throw new Error("Expected 32 bytes of private key");
        num = hexToNumber(key);
      } else if (key instanceof Uint8Array) {
        if (key.length !== groupLen)
          throw new Error("Expected 32 bytes of private key");
        num = bytesToNumber(key);
      } else {
        throw new TypeError("Expected valid private key");
      }
      if (!isWithinCurveOrder(num))
        throw new Error("Expected private key: 0 < key < n");
      return num;
    }
    function normalizePublicKey(publicKey) {
      if (publicKey instanceof Point2) {
        publicKey.assertValidity();
        return publicKey;
      } else {
        return Point2.fromHex(publicKey);
      }
    }
    function normalizeSignature(signature) {
      if (signature instanceof Signature2) {
        signature.assertValidity();
        return signature;
      }
      try {
        return Signature2.fromDER(signature);
      } catch (error) {
        return Signature2.fromCompact(signature);
      }
    }
    function getPublicKey2(privateKey, isCompressed = false) {
      return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    exports.getPublicKey = getPublicKey2;
    function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {
      return Point2.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);
    }
    exports.recoverPublicKey = recoverPublicKey;
    function isProbPub(item) {
      const arr = item instanceof Uint8Array;
      const str = typeof item === "string";
      const len = (arr || str) && item.length;
      if (arr)
        return len === compressedLen || len === uncompressedLen;
      if (str)
        return len === compressedLen * 2 || len === uncompressedLen * 2;
      if (item instanceof Point2)
        return true;
      return false;
    }
    function getSharedSecret2(privateA, publicB, isCompressed = false) {
      if (isProbPub(privateA))
        throw new TypeError("getSharedSecret: first arg must be private key");
      if (!isProbPub(publicB))
        throw new TypeError("getSharedSecret: second arg must be public key");
      const b2 = normalizePublicKey(publicB);
      b2.assertValidity();
      return b2.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);
    }
    exports.getSharedSecret = getSharedSecret2;
    function bits2int(bytes) {
      const slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;
      return bytesToNumber(slice);
    }
    function bits2octets(bytes) {
      const z1 = bits2int(bytes);
      const z2 = mod(z1, CURVE.n);
      return int2octets(z2 < _0n ? z1 : z2);
    }
    function int2octets(num) {
      return numTo32b(num);
    }
    function initSigArgs(msgHash, privateKey, extraEntropy) {
      if (msgHash == null)
        throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
      const h1 = ensureBytes(msgHash);
      const d2 = normalizePrivateKey(privateKey);
      const seedArgs = [int2octets(d2), bits2octets(h1)];
      if (extraEntropy != null) {
        if (extraEntropy === true)
          extraEntropy = exports.utils.randomBytes(fieldLen);
        const e = ensureBytes(extraEntropy);
        if (e.length !== fieldLen)
          throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);
        seedArgs.push(e);
      }
      const seed = concatBytes2(...seedArgs);
      const m2 = bits2int(h1);
      return { seed, m: m2, d: d2 };
    }
    function finalizeSig(recSig, opts) {
      const { sig, recovery } = recSig;
      const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);
      const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
      return recovered ? [hashed, recovery] : hashed;
    }
    async function sign(msgHash, privKey, opts = {}) {
      const { seed, m: m2, d: d2 } = initSigArgs(msgHash, privKey, opts.extraEntropy);
      const drbg = new HmacDrbg(hashLen, groupLen);
      await drbg.reseed(seed);
      let sig;
      while (!(sig = kmdToSig(await drbg.generate(), m2, d2, opts.canonical)))
        await drbg.reseed();
      return finalizeSig(sig, opts);
    }
    exports.sign = sign;
    function signSync2(msgHash, privKey, opts = {}) {
      const { seed, m: m2, d: d2 } = initSigArgs(msgHash, privKey, opts.extraEntropy);
      const drbg = new HmacDrbg(hashLen, groupLen);
      drbg.reseedSync(seed);
      let sig;
      while (!(sig = kmdToSig(drbg.generateSync(), m2, d2, opts.canonical)))
        drbg.reseedSync();
      return finalizeSig(sig, opts);
    }
    exports.signSync = signSync2;
    var vopts = { strict: true };
    function verify2(signature, msgHash, publicKey, opts = vopts) {
      let sig;
      try {
        sig = normalizeSignature(signature);
        msgHash = ensureBytes(msgHash);
      } catch (error) {
        return false;
      }
      const { r, s } = sig;
      if (opts.strict && sig.hasHighS())
        return false;
      const h = truncateHash(msgHash);
      let P;
      try {
        P = normalizePublicKey(publicKey);
      } catch (error) {
        return false;
      }
      const { n } = CURVE;
      const sinv = invert(s, n);
      const u1 = mod(h * sinv, n);
      const u2 = mod(r * sinv, n);
      const R2 = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2);
      if (!R2)
        return false;
      const v = mod(R2.x, n);
      return v === r;
    }
    exports.verify = verify2;
    function schnorrChallengeFinalize(ch) {
      return mod(bytesToNumber(ch), CURVE.n);
    }
    var SchnorrSignature = class _SchnorrSignature {
      constructor(r, s) {
        this.r = r;
        this.s = s;
        this.assertValidity();
      }
      static fromHex(hex) {
        const bytes = ensureBytes(hex);
        if (bytes.length !== 64)
          throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);
        const r = bytesToNumber(bytes.subarray(0, 32));
        const s = bytesToNumber(bytes.subarray(32, 64));
        return new _SchnorrSignature(r, s);
      }
      assertValidity() {
        const { r, s } = this;
        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))
          throw new Error("Invalid signature");
      }
      toHex() {
        return numTo32bStr(this.r) + numTo32bStr(this.s);
      }
      toRawBytes() {
        return hexToBytes2(this.toHex());
      }
    };
    function schnorrGetPublicKey(privateKey) {
      return Point2.fromPrivateKey(privateKey).toRawX();
    }
    var InternalSchnorrSignature = class {
      constructor(message, privateKey, auxRand = exports.utils.randomBytes()) {
        if (message == null)
          throw new TypeError(`sign: Expected valid message, not "${message}"`);
        this.m = ensureBytes(message);
        const { x: x2, scalar } = this.getScalar(normalizePrivateKey(privateKey));
        this.px = x2;
        this.d = scalar;
        this.rand = ensureBytes(auxRand);
        if (this.rand.length !== 32)
          throw new TypeError("sign: Expected 32 bytes of aux randomness");
      }
      getScalar(priv) {
        const point = Point2.fromPrivateKey(priv);
        const scalar = point.hasEvenY() ? priv : CURVE.n - priv;
        return { point, scalar, x: point.toRawX() };
      }
      initNonce(d2, t0h) {
        return numTo32b(d2 ^ bytesToNumber(t0h));
      }
      finalizeNonce(k0h) {
        const k0 = mod(bytesToNumber(k0h), CURVE.n);
        if (k0 === _0n)
          throw new Error("sign: Creation of signature failed. k is zero");
        const { point: R2, x: rx, scalar: k2 } = this.getScalar(k0);
        return { R: R2, rx, k: k2 };
      }
      finalizeSig(R2, k2, e, d2) {
        return new SchnorrSignature(R2.x, mod(k2 + e * d2, CURVE.n)).toRawBytes();
      }
      error() {
        throw new Error("sign: Invalid signature produced");
      }
      async calc() {
        const { m: m2, d: d2, px, rand } = this;
        const tag = exports.utils.taggedHash;
        const t = this.initNonce(d2, await tag(TAGS.aux, rand));
        const { R: R2, rx, k: k2 } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m2));
        const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m2));
        const sig = this.finalizeSig(R2, k2, e, d2);
        if (!await schnorrVerify(sig, m2, px))
          this.error();
        return sig;
      }
      calcSync() {
        const { m: m2, d: d2, px, rand } = this;
        const tag = exports.utils.taggedHashSync;
        const t = this.initNonce(d2, tag(TAGS.aux, rand));
        const { R: R2, rx, k: k2 } = this.finalizeNonce(tag(TAGS.nonce, t, px, m2));
        const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m2));
        const sig = this.finalizeSig(R2, k2, e, d2);
        if (!schnorrVerifySync(sig, m2, px))
          this.error();
        return sig;
      }
    };
    async function schnorrSign(msg, privKey, auxRand) {
      return new InternalSchnorrSignature(msg, privKey, auxRand).calc();
    }
    function schnorrSignSync(msg, privKey, auxRand) {
      return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();
    }
    function initSchnorrVerify(signature, message, publicKey) {
      const raw = signature instanceof SchnorrSignature;
      const sig = raw ? signature : SchnorrSignature.fromHex(signature);
      if (raw)
        sig.assertValidity();
      return {
        ...sig,
        m: ensureBytes(message),
        P: normalizePublicKey(publicKey)
      };
    }
    function finalizeSchnorrVerify(r, P, s, e) {
      const R2 = Point2.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));
      if (!R2 || !R2.hasEvenY() || R2.x !== r)
        return false;
      return true;
    }
    async function schnorrVerify(signature, message, publicKey) {
      try {
        const { r, s, m: m2, P } = initSchnorrVerify(signature, message, publicKey);
        const e = schnorrChallengeFinalize(await exports.utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m2));
        return finalizeSchnorrVerify(r, P, s, e);
      } catch (error) {
        return false;
      }
    }
    function schnorrVerifySync(signature, message, publicKey) {
      try {
        const { r, s, m: m2, P } = initSchnorrVerify(signature, message, publicKey);
        const e = schnorrChallengeFinalize(exports.utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m2));
        return finalizeSchnorrVerify(r, P, s, e);
      } catch (error) {
        if (error instanceof ShaError)
          throw error;
        return false;
      }
    }
    exports.schnorr = {
      Signature: SchnorrSignature,
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify,
      signSync: schnorrSignSync,
      verifySync: schnorrVerifySync
    };
    Point2.BASE._setWindowSize(8);
    var crypto2 = {
      node: nodeCrypto,
      web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
    };
    var TAGS = {
      challenge: "BIP0340/challenge",
      aux: "BIP0340/aux",
      nonce: "BIP0340/nonce"
    };
    var TAGGED_HASH_PREFIXES = {};
    exports.utils = {
      bytesToHex: bytesToHex2,
      hexToBytes: hexToBytes2,
      concatBytes: concatBytes2,
      mod,
      invert,
      isValidPrivateKey(privateKey) {
        try {
          normalizePrivateKey(privateKey);
          return true;
        } catch (error) {
          return false;
        }
      },
      _bigintTo32Bytes: numTo32b,
      _normalizePrivateKey: normalizePrivateKey,
      hashToPrivateKey: (hash) => {
        hash = ensureBytes(hash);
        const minLen = groupLen + 8;
        if (hash.length < minLen || hash.length > 1024) {
          throw new Error(`Expected valid bytes of private key as per FIPS 186`);
        }
        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;
        return numTo32b(num);
      },
      randomBytes: (bytesLength = 32) => {
        if (crypto2.web) {
          return crypto2.web.getRandomValues(new Uint8Array(bytesLength));
        } else if (crypto2.node) {
          const { randomBytes: randomBytes2 } = crypto2.node;
          return Uint8Array.from(randomBytes2(bytesLength));
        } else {
          throw new Error("The environment doesn't have randomBytes function");
        }
      },
      randomPrivateKey: () => exports.utils.hashToPrivateKey(exports.utils.randomBytes(groupLen + 8)),
      precompute(windowSize = 8, point = Point2.BASE) {
        const cached = point === Point2.BASE ? point : new Point2(point.x, point.y);
        cached._setWindowSize(windowSize);
        cached.multiply(_3n);
        return cached;
      },
      sha256: async (...messages) => {
        if (crypto2.web) {
          const buffer = await crypto2.web.subtle.digest("SHA-256", concatBytes2(...messages));
          return new Uint8Array(buffer);
        } else if (crypto2.node) {
          const { createHash } = crypto2.node;
          const hash = createHash("sha256");
          messages.forEach((m2) => hash.update(m2));
          return Uint8Array.from(hash.digest());
        } else {
          throw new Error("The environment doesn't have sha256 function");
        }
      },
      hmacSha256: async (key, ...messages) => {
        if (crypto2.web) {
          const ckey = await crypto2.web.subtle.importKey("raw", key, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
          const message = concatBytes2(...messages);
          const buffer = await crypto2.web.subtle.sign("HMAC", ckey, message);
          return new Uint8Array(buffer);
        } else if (crypto2.node) {
          const { createHmac } = crypto2.node;
          const hash = createHmac("sha256", key);
          messages.forEach((m2) => hash.update(m2));
          return Uint8Array.from(hash.digest());
        } else {
          throw new Error("The environment doesn't have hmac-sha256 function");
        }
      },
      sha256Sync: void 0,
      hmacSha256Sync: void 0,
      taggedHash: async (tag, ...messages) => {
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === void 0) {
          const tagH = await exports.utils.sha256(Uint8Array.from(tag, (c2) => c2.charCodeAt(0)));
          tagP = concatBytes2(tagH, tagH);
          TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return exports.utils.sha256(tagP, ...messages);
      },
      taggedHashSync: (tag, ...messages) => {
        if (typeof _sha256Sync !== "function")
          throw new ShaError("sha256Sync is undefined, you need to set it");
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === void 0) {
          const tagH = _sha256Sync(Uint8Array.from(tag, (c2) => c2.charCodeAt(0)));
          tagP = concatBytes2(tagH, tagH);
          TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return _sha256Sync(tagP, ...messages);
      },
      _JacobianPoint: JacobianPoint
    };
    Object.defineProperties(exports.utils, {
      sha256Sync: {
        configurable: false,
        get() {
          return _sha256Sync;
        },
        set(val) {
          if (!_sha256Sync)
            _sha256Sync = val;
        }
      },
      hmacSha256Sync: {
        configurable: false,
        get() {
          return _hmacSha256Sync;
        },
        set(val) {
          if (!_hmacSha256Sync)
            _hmacSha256Sync = val;
        }
      }
    });
  }
});

// node_modules/jsontokens/lib/ecdsaSigFormatter.js
var require_ecdsaSigFormatter = __commonJS({
  "node_modules/jsontokens/lib/ecdsaSigFormatter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joseToDer = exports.derToJose = void 0;
    var base64_js_1 = require_base64_js();
    var base64Url_1 = require_base64Url();
    function getParamSize(keySize) {
      return (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
    }
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521)
    };
    function getParamBytesForAlg(alg) {
      const paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error(`Unknown algorithm "${alg}"`);
    }
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
    var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
    function signatureAsBytes(signature) {
      if (signature instanceof Uint8Array) {
        return signature;
      } else if ("string" === typeof signature) {
        return (0, base64_js_1.toByteArray)((0, base64Url_1.pad)(signature));
      }
      throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
    }
    function derToJose(signature, alg) {
      const signatureBytes = signatureAsBytes(signature);
      const paramBytes = getParamBytesForAlg(alg);
      const maxEncodedParamLength = paramBytes + 1;
      const inputLength = signatureBytes.length;
      let offset = 0;
      if (signatureBytes[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      let seqLength = signatureBytes[offset++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signatureBytes[offset++];
      }
      if (inputLength - offset < seqLength) {
        throw new Error(`"seq" specified length of "${seqLength}", only "${inputLength - offset}" remaining`);
      }
      if (signatureBytes[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      const rLength = signatureBytes[offset++];
      if (inputLength - offset - 2 < rLength) {
        throw new Error(`"r" specified length of "${rLength}", only "${inputLength - offset - 2}" available`);
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error(`"r" specified length of "${rLength}", max of "${maxEncodedParamLength}" is acceptable`);
      }
      const rOffset = offset;
      offset += rLength;
      if (signatureBytes[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      const sLength = signatureBytes[offset++];
      if (inputLength - offset !== sLength) {
        throw new Error(`"s" specified length of "${sLength}", expected "${inputLength - offset}"`);
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error(`"s" specified length of "${sLength}", max of "${maxEncodedParamLength}" is acceptable`);
      }
      const sOffset = offset;
      offset += sLength;
      if (offset !== inputLength) {
        throw new Error(`Expected to consume entire array, but "${inputLength - offset}" bytes remain`);
      }
      const rPadding = paramBytes - rLength;
      const sPadding = paramBytes - sLength;
      const dst = new Uint8Array(rPadding + rLength + sPadding + sLength);
      for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
      }
      dst.set(signatureBytes.subarray(rOffset + Math.max(-rPadding, 0), rOffset + rLength), offset);
      offset = paramBytes;
      for (const o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
      }
      dst.set(signatureBytes.subarray(sOffset + Math.max(-sPadding, 0), sOffset + sLength), offset);
      return (0, base64Url_1.escape)((0, base64_js_1.fromByteArray)(dst));
    }
    exports.derToJose = derToJose;
    function countPadding(buf, start, stop) {
      let padding = 0;
      while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
      }
      const needsSign = buf[start + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    function joseToDer(signature, alg) {
      signature = signatureAsBytes(signature);
      const paramBytes = getParamBytesForAlg(alg);
      const signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError(`"${alg}" signatures must be "${paramBytes * 2}" bytes, saw "${signatureBytes}"`);
      }
      const rPadding = countPadding(signature, 0, paramBytes);
      const sPadding = countPadding(signature, paramBytes, signature.length);
      const rLength = paramBytes - rPadding;
      const sLength = paramBytes - sPadding;
      const rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      const shortLength = rsBytes < MAX_OCTET;
      const dst = new Uint8Array((shortLength ? 2 : 3) + rsBytes);
      let offset = 0;
      dst[offset++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset++] = rsBytes;
      } else {
        dst[offset++] = MAX_OCTET | 1;
        dst[offset++] = rsBytes & 255;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = rLength;
      if (rPadding < 0) {
        dst[offset++] = 0;
        dst.set(signature.subarray(0, paramBytes), offset);
        offset += paramBytes;
      } else {
        dst.set(signature.subarray(rPadding, paramBytes), offset);
        offset += paramBytes - rPadding;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = sLength;
      if (sPadding < 0) {
        dst[offset++] = 0;
        dst.set(signature.subarray(paramBytes), offset);
      } else {
        dst.set(signature.subarray(paramBytes + sPadding), offset);
      }
      return dst;
    }
    exports.joseToDer = joseToDer;
  }
});

// node_modules/jsontokens/lib/errors.js
var require_errors = __commonJS({
  "node_modules/jsontokens/lib/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidTokenError = exports.MissingParametersError = void 0;
    var MissingParametersError = class extends Error {
      constructor(message) {
        super();
        this.name = "MissingParametersError";
        this.message = message || "";
      }
    };
    exports.MissingParametersError = MissingParametersError;
    var InvalidTokenError = class extends Error {
      constructor(message) {
        super();
        this.name = "InvalidTokenError";
        this.message = message || "";
      }
    };
    exports.InvalidTokenError = InvalidTokenError;
  }
});

// node_modules/jsontokens/lib/cryptoClients/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/jsontokens/lib/cryptoClients/secp256k1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SECP256K1Client = void 0;
    var hmac_1 = require_hmac();
    var sha256_1 = require_sha256();
    var secp = require_lib2();
    var ecdsaSigFormatter_1 = require_ecdsaSigFormatter();
    var errors_1 = require_errors();
    var utils_1 = require_utils();
    secp.utils.hmacSha256Sync = (key, ...msgs) => {
      const h = hmac_1.hmac.create(sha256_1.sha256, key);
      msgs.forEach((msg) => h.update(msg));
      return h.digest();
    };
    var SECP256K1Client4 = class {
      static derivePublicKey(privateKey, compressed = true) {
        if (privateKey.length === 66) {
          privateKey = privateKey.slice(0, 64);
        }
        if (privateKey.length < 64) {
          privateKey = privateKey.padStart(64, "0");
        }
        return (0, utils_1.bytesToHex)(secp.getPublicKey(privateKey, compressed));
      }
      static signHash(signingInputHash, privateKey, format = "jose") {
        if (!signingInputHash || !privateKey) {
          throw new errors_1.MissingParametersError("a signing input hash and private key are all required");
        }
        const derSignature = secp.signSync(signingInputHash, privateKey.slice(0, 64), {
          der: true,
          canonical: false
        });
        if (format === "der")
          return (0, utils_1.bytesToHex)(derSignature);
        if (format === "jose")
          return (0, ecdsaSigFormatter_1.derToJose)(derSignature, "ES256");
        throw Error("Invalid signature format");
      }
      static loadSignature(joseSignature) {
        return (0, ecdsaSigFormatter_1.joseToDer)(joseSignature, "ES256");
      }
      static verifyHash(signingInputHash, derSignatureBytes, publicKey) {
        if (!signingInputHash || !derSignatureBytes || !publicKey) {
          throw new errors_1.MissingParametersError("a signing input hash, der signature, and public key are all required");
        }
        return secp.verify(derSignatureBytes, signingInputHash, publicKey, { strict: false });
      }
    };
    exports.SECP256K1Client = SECP256K1Client4;
    SECP256K1Client4.algorithmName = "ES256K";
  }
});

// node_modules/jsontokens/lib/cryptoClients/index.js
var require_cryptoClients = __commonJS({
  "node_modules/jsontokens/lib/cryptoClients/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cryptoClients = exports.SECP256K1Client = void 0;
    var secp256k1_1 = require_secp256k1();
    Object.defineProperty(exports, "SECP256K1Client", { enumerable: true, get: function() {
      return secp256k1_1.SECP256K1Client;
    } });
    var cryptoClients = {
      ES256K: secp256k1_1.SECP256K1Client
    };
    exports.cryptoClients = cryptoClients;
  }
});

// node_modules/jsontokens/lib/cryptoClients/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/jsontokens/lib/cryptoClients/sha256.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashSha256Async = exports.hashSha256 = void 0;
    var sha256_1 = require_sha256();
    function hashSha256(input) {
      return (0, sha256_1.sha256)(input);
    }
    exports.hashSha256 = hashSha256;
    function hashSha256Async(input) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          const isSubtleCryptoAvailable2 = typeof crypto !== "undefined" && typeof crypto.subtle !== "undefined";
          if (isSubtleCryptoAvailable2) {
            const bytes = typeof input === "string" ? new TextEncoder().encode(input) : input;
            const hash = yield crypto.subtle.digest("SHA-256", bytes);
            return new Uint8Array(hash);
          } else {
            const nodeCrypto = require_crypto();
            if (!nodeCrypto.createHash) {
              throw new Error("`crypto` module does not contain `createHash`");
            }
            return Promise.resolve(nodeCrypto.createHash("sha256").update(input).digest());
          }
        } catch (error) {
          console.log(error);
          console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.');
          return Promise.resolve(hashSha256(input));
        }
      });
    }
    exports.hashSha256Async = hashSha256Async;
  }
});

// node_modules/jsontokens/lib/signer.js
var require_signer = __commonJS({
  "node_modules/jsontokens/lib/signer.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenSigner = exports.createUnsecuredToken = void 0;
    var base64url = require_base64Url();
    var cryptoClients_1 = require_cryptoClients();
    var errors_1 = require_errors();
    var sha256_1 = require_sha2562();
    function createSigningInput(payload, header) {
      const tokenParts = [];
      const encodedHeader = base64url.encode(JSON.stringify(header));
      tokenParts.push(encodedHeader);
      const encodedPayload = base64url.encode(JSON.stringify(payload));
      tokenParts.push(encodedPayload);
      const signingInput = tokenParts.join(".");
      return signingInput;
    }
    function createUnsecuredToken2(payload) {
      const header = { typ: "JWT", alg: "none" };
      return createSigningInput(payload, header) + ".";
    }
    exports.createUnsecuredToken = createUnsecuredToken2;
    var TokenSigner4 = class {
      constructor(signingAlgorithm, rawPrivateKey) {
        if (!(signingAlgorithm && rawPrivateKey)) {
          throw new errors_1.MissingParametersError("a signing algorithm and private key are required");
        }
        if (typeof signingAlgorithm !== "string") {
          throw new Error("signing algorithm parameter must be a string");
        }
        signingAlgorithm = signingAlgorithm.toUpperCase();
        if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {
          throw new Error("invalid signing algorithm");
        }
        this.tokenType = "JWT";
        this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];
        this.rawPrivateKey = rawPrivateKey;
      }
      header(header = {}) {
        const defaultHeader = { typ: this.tokenType, alg: this.cryptoClient.algorithmName };
        return Object.assign({}, defaultHeader, header);
      }
      sign(payload, expanded = false, customHeader = {}) {
        const header = this.header(customHeader);
        const signingInput = createSigningInput(payload, header);
        const signingInputHash = (0, sha256_1.hashSha256)(signingInput);
        return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);
      }
      signAsync(payload, expanded = false, customHeader = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const header = this.header(customHeader);
          const signingInput = createSigningInput(payload, header);
          const signingInputHash = yield (0, sha256_1.hashSha256Async)(signingInput);
          return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);
        });
      }
      createWithSignedHash(payload, expanded, header, signingInput, signingInputHash) {
        const signature = this.cryptoClient.signHash(signingInputHash, this.rawPrivateKey);
        if (expanded) {
          const signedToken = {
            header: [base64url.encode(JSON.stringify(header))],
            payload: JSON.stringify(payload),
            signature: [signature]
          };
          return signedToken;
        } else {
          return [signingInput, signature].join(".");
        }
      }
    };
    exports.TokenSigner = TokenSigner4;
  }
});

// node_modules/jsontokens/lib/verifier.js
var require_verifier = __commonJS({
  "node_modules/jsontokens/lib/verifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenVerifier = void 0;
    var base64url = require_base64Url();
    var cryptoClients_1 = require_cryptoClients();
    var errors_1 = require_errors();
    var sha256_1 = require_sha2562();
    var TokenVerifier3 = class {
      constructor(signingAlgorithm, rawPublicKey) {
        if (!(signingAlgorithm && rawPublicKey)) {
          throw new errors_1.MissingParametersError("a signing algorithm and public key are required");
        }
        if (typeof signingAlgorithm !== "string") {
          throw "signing algorithm parameter must be a string";
        }
        signingAlgorithm = signingAlgorithm.toUpperCase();
        if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {
          throw "invalid signing algorithm";
        }
        this.tokenType = "JWT";
        this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];
        this.rawPublicKey = rawPublicKey;
      }
      verify(token) {
        if (typeof token === "string") {
          return this.verifyCompact(token, false);
        } else if (typeof token === "object") {
          return this.verifyExpanded(token, false);
        } else {
          return false;
        }
      }
      verifyAsync(token) {
        if (typeof token === "string") {
          return this.verifyCompact(token, true);
        } else if (typeof token === "object") {
          return this.verifyExpanded(token, true);
        } else {
          return Promise.resolve(false);
        }
      }
      verifyCompact(token, async) {
        const tokenParts = token.split(".");
        const signingInput = tokenParts[0] + "." + tokenParts[1];
        const performVerify = (signingInputHash) => {
          const derSignatureBytes = this.cryptoClient.loadSignature(tokenParts[2]);
          return this.cryptoClient.verifyHash(signingInputHash, derSignatureBytes, this.rawPublicKey);
        };
        if (async) {
          return (0, sha256_1.hashSha256Async)(signingInput).then((signingInputHash) => performVerify(signingInputHash));
        } else {
          const signingInputHash = (0, sha256_1.hashSha256)(signingInput);
          return performVerify(signingInputHash);
        }
      }
      verifyExpanded(token, async) {
        const signingInput = [token["header"].join("."), base64url.encode(token["payload"])].join(".");
        let verified = true;
        const performVerify = (signingInputHash) => {
          token["signature"].map((signature) => {
            const derSignatureBytes = this.cryptoClient.loadSignature(signature);
            const signatureVerified = this.cryptoClient.verifyHash(signingInputHash, derSignatureBytes, this.rawPublicKey);
            if (!signatureVerified) {
              verified = false;
            }
          });
          return verified;
        };
        if (async) {
          return (0, sha256_1.hashSha256Async)(signingInput).then((signingInputHash) => performVerify(signingInputHash));
        } else {
          const signingInputHash = (0, sha256_1.hashSha256)(signingInput);
          return performVerify(signingInputHash);
        }
      }
    };
    exports.TokenVerifier = TokenVerifier3;
  }
});

// node_modules/jsontokens/lib/decode.js
var require_decode = __commonJS({
  "node_modules/jsontokens/lib/decode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeToken = void 0;
    var base64url = require_base64Url();
    function decodeToken6(token) {
      if (typeof token === "string") {
        const tokenParts = token.split(".");
        const header = JSON.parse(base64url.decode(tokenParts[0]));
        const payload = JSON.parse(base64url.decode(tokenParts[1]));
        const signature = tokenParts[2];
        return {
          header,
          payload,
          signature
        };
      } else if (typeof token === "object") {
        if (typeof token.payload !== "string") {
          throw new Error("Expected token payload to be a base64 or json string");
        }
        let payload = token.payload;
        if (token.payload[0] !== "{") {
          payload = base64url.decode(payload);
        }
        const allHeaders = [];
        token.header.map((headerValue) => {
          const header = JSON.parse(base64url.decode(headerValue));
          allHeaders.push(header);
        });
        return {
          header: allHeaders,
          payload: JSON.parse(payload),
          signature: token.signature
        };
      }
    }
    exports.decodeToken = decodeToken6;
  }
});

// node_modules/jsontokens/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/jsontokens/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p in m2)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m2, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_signer(), exports);
    __exportStar(require_verifier(), exports);
    __exportStar(require_decode(), exports);
    __exportStar(require_errors(), exports);
    __exportStar(require_cryptoClients(), exports);
  }
});

// node_modules/zone-file/dist/zone-file.cjs.development.js
var require_zone_file_cjs_development = __commonJS({
  "node_modules/zone-file/dist/zone-file.cjs.development.js"(exports) {
    "use strict";
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it2;
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it2)
            o = it2;
          var i = 0;
          return function() {
            if (i >= o.length)
              return {
                done: true
              };
            return {
              done: false,
              value: o[i++]
            };
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      it2 = o[Symbol.iterator]();
      return it2.next.bind(it2);
    }
    function getZoneFileTemplate() {
      return "{$origin}\n{$ttl}\n\n; SOA Record\n{name} {ttl}    IN  SOA {mname}{rname}(\n{serial} ;serial\n{refresh} ;refresh\n{retry} ;retry\n{expire} ;expire\n{minimum} ;minimum ttl\n)\n\n; NS Records\n{ns}\n\n; MX Records\n{mx}\n\n; A Records\n{a}\n\n; AAAA Records\n{aaaa}\n\n; CNAME Records\n{cname}\n\n; PTR Records\n{ptr}\n\n; TXT Records\n{txt}\n\n; SRV Records\n{srv}\n\n; SPF Records\n{spf}\n\n; URI Records\n{uri}\n";
    }
    function makeZoneFile2(jsonZoneFile, template) {
      if (template === void 0) {
        template = getZoneFileTemplate();
      }
      template = processOrigin(jsonZoneFile["$origin"], template);
      template = processTTL(jsonZoneFile["$ttl"], template);
      template = processSOA(jsonZoneFile["soa"], template);
      template = processNS(jsonZoneFile["ns"], template);
      template = processA(jsonZoneFile["a"], template);
      template = processAAAA(jsonZoneFile["aaaa"], template);
      template = processCNAME(jsonZoneFile["cname"], template);
      template = processMX(jsonZoneFile["mx"], template);
      template = processPTR(jsonZoneFile["ptr"], template);
      template = processTXT(jsonZoneFile["txt"], template);
      template = processSRV(jsonZoneFile["srv"], template);
      template = processSPF(jsonZoneFile["spf"], template);
      template = processURI(jsonZoneFile["uri"], template);
      template = processValues(jsonZoneFile, template);
      return template.replace(/\n{2,}/gim, "\n\n");
    }
    function processOrigin(data, template) {
      var ret = "";
      if (typeof data !== "undefined") {
        ret += "$ORIGIN " + data;
      }
      return template.replace("{$origin}", ret);
    }
    function processTTL(data, template) {
      var ret = "";
      if (typeof data !== "undefined") {
        ret += "$TTL " + data;
      }
      return template.replace("{$ttl}", ret);
    }
    function processSOA(data, template) {
      var ret = template;
      if (typeof data !== "undefined") {
        data.name = data.name || "@";
        data.ttl = data.ttl || "";
        for (var key in data) {
          var value = data[key];
          ret = ret.replace("{" + key + "}", value + "	");
        }
      }
      return ret;
    }
    function processNS(data, template) {
      var ret = "";
      if (data) {
        for (var _iterator = _createForOfIteratorHelperLoose(data), _step; !(_step = _iterator()).done; ) {
          var record = _step.value;
          ret += (record.name || "@") + "	";
          if (record.ttl)
            ret += record.ttl + "	";
          ret += "IN	NS	" + record.host + "\n";
        }
      }
      return template.replace("{ns}", ret);
    }
    function processA(data, template) {
      var ret = "";
      if (data) {
        for (var _iterator2 = _createForOfIteratorHelperLoose(data), _step2; !(_step2 = _iterator2()).done; ) {
          var record = _step2.value;
          ret += (record.name || "@") + "	";
          if (record.ttl)
            ret += record.ttl + "	";
          ret += "IN	A	" + record.ip + "\n";
        }
      }
      return template.replace("{a}", ret);
    }
    function processAAAA(data, template) {
      var ret = "";
      if (data) {
        for (var _iterator3 = _createForOfIteratorHelperLoose(data), _step3; !(_step3 = _iterator3()).done; ) {
          var record = _step3.value;
          ret += (record.name || "@") + "	";
          if (record.ttl)
            ret += record.ttl + "	";
          ret += "IN	AAAA	" + record.ip + "\n";
        }
      }
      return template.replace("{aaaa}", ret);
    }
    function processCNAME(data, template) {
      var ret = "";
      if (data) {
        for (var _iterator4 = _createForOfIteratorHelperLoose(data), _step4; !(_step4 = _iterator4()).done; ) {
          var record = _step4.value;
          ret += (record.name || "@") + "	";
          if (record.ttl)
            ret += record.ttl + "	";
          ret += "IN	CNAME	" + record.alias + "\n";
        }
      }
      return template.replace("{cname}", ret);
    }
    function processMX(data, template) {
      var ret = "";
      if (data) {
        for (var _iterator5 = _createForOfIteratorHelperLoose(data), _step5; !(_step5 = _iterator5()).done; ) {
          var record = _step5.value;
          ret += (record.name || "@") + "	";
          if (record.ttl)
            ret += record.ttl + "	";
          ret += "IN	MX	" + record.preference + "	" + record.host + "\n";
        }
      }
      return template.replace("{mx}", ret);
    }
    function processPTR(data, template) {
      var ret = "";
      if (data) {
        for (var _iterator6 = _createForOfIteratorHelperLoose(data), _step6; !(_step6 = _iterator6()).done; ) {
          var record = _step6.value;
          ret += (record.name || "@") + "	";
          if (record.ttl)
            ret += record.ttl + "	";
          ret += "IN	PTR	" + record.host + "\n";
        }
      }
      return template.replace("{ptr}", ret);
    }
    function processTXT(data, template) {
      var ret = "";
      if (data) {
        for (var _iterator7 = _createForOfIteratorHelperLoose(data), _step7; !(_step7 = _iterator7()).done; ) {
          var record = _step7.value;
          ret += (record.name || "@") + "	";
          if (record.ttl)
            ret += record.ttl + "	";
          ret += "IN	TXT	";
          var txtData = record.txt;
          if (typeof txtData === "string") {
            ret += '"' + txtData + '"';
          } else if (txtData instanceof Array) {
            ret += txtData.map(function(datum) {
              return '"' + datum + '"';
            }).join(" ");
          }
          ret += "\n";
        }
      }
      return template.replace("{txt}", ret);
    }
    function processSRV(data, template) {
      var ret = "";
      if (data) {
        for (var _iterator8 = _createForOfIteratorHelperLoose(data), _step8; !(_step8 = _iterator8()).done; ) {
          var record = _step8.value;
          ret += (record.name || "@") + "	";
          if (record.ttl)
            ret += record.ttl + "	";
          ret += "IN	SRV	" + record.priority + "	";
          ret += record.weight + "	";
          ret += record.port + "	";
          ret += record.target + "\n";
        }
      }
      return template.replace("{srv}", ret);
    }
    function processSPF(data, template) {
      var ret = "";
      if (data) {
        for (var _iterator9 = _createForOfIteratorHelperLoose(data), _step9; !(_step9 = _iterator9()).done; ) {
          var record = _step9.value;
          ret += (record.name || "@") + "	";
          if (record.ttl)
            ret += record.ttl + "	";
          ret += "IN	SPF	" + record.data + "\n";
        }
      }
      return template.replace("{spf}", ret);
    }
    function processURI(data, template) {
      var ret = "";
      if (data) {
        for (var _iterator10 = _createForOfIteratorHelperLoose(data), _step10; !(_step10 = _iterator10()).done; ) {
          var record = _step10.value;
          ret += (record.name || "@") + "	";
          if (record.ttl)
            ret += record.ttl + "	";
          ret += "IN	URI	" + record.priority + "	";
          ret += record.weight + "	";
          ret += '"' + record.target + '"\n';
        }
      }
      return template.replace("{uri}", ret);
    }
    function processValues(jsonZoneFile, template) {
      template = template.replace("{zone}", jsonZoneFile["$origin"] || (jsonZoneFile["soa"] ? jsonZoneFile["soa"]["name"] : false) || "");
      template = template.replace("{datetime}", (/* @__PURE__ */ new Date()).toISOString());
      var time = Math.round(Date.now() / 1e3);
      return template.replace("{time}", "" + time);
    }
    function parseZoneFile3(text) {
      text = removeComments(text);
      text = flatten(text);
      return parseRRs(text);
    }
    function removeComments(text) {
      var re = /(^|[^\\]);.*/g;
      return text.replace(re, function(_m, g1) {
        return g1 ? g1 : "";
      });
    }
    function flatten(text) {
      var captured = [];
      var re = /\([\s\S]*?\)/gim;
      var match = re.exec(text);
      while (match !== null) {
        var replacement = match[0].replace(/\s+/gm, " ");
        captured.push({
          match,
          replacement
        });
        match = re.exec(text);
      }
      var arrText = text.split("");
      for (var _i = 0, _captured = captured; _i < _captured.length; _i++) {
        var cur = _captured[_i];
        var _match = cur.match, _replacement = cur.replacement;
        arrText.splice(_match.index, _match[0].length, _replacement);
      }
      return arrText.join("").replace(/\(|\)/gim, " ");
    }
    function parseRRs(text) {
      var ret = {};
      var rrs = text.split("\n");
      for (var _iterator = _createForOfIteratorHelperLoose(rrs), _step; !(_step = _iterator()).done; ) {
        var rr = _step.value;
        if (!rr || !rr.trim()) {
          continue;
        }
        var uRR = rr.toUpperCase();
        if (/\s+TXT\s+/.test(uRR)) {
          ret.txt = ret.txt || [];
          ret.txt.push(parseTXT(rr));
        } else if (uRR.indexOf("$ORIGIN") === 0) {
          ret.$origin = rr.split(/\s+/g)[1];
        } else if (uRR.indexOf("$TTL") === 0) {
          ret.$ttl = parseInt(rr.split(/\s+/g)[1], 10);
        } else if (/\s+SOA\s+/.test(uRR)) {
          ret.soa = parseSOA(rr);
        } else if (/\s+NS\s+/.test(uRR)) {
          ret.ns = ret.ns || [];
          ret.ns.push(parseNS(rr));
        } else if (/\s+A\s+/.test(uRR)) {
          ret.a = ret.a || [];
          ret.a.push(parseA(rr, ret.a));
        } else if (/\s+AAAA\s+/.test(uRR)) {
          ret.aaaa = ret.aaaa || [];
          ret.aaaa.push(parseAAAA(rr));
        } else if (/\s+CNAME\s+/.test(uRR)) {
          ret.cname = ret.cname || [];
          ret.cname.push(parseCNAME(rr));
        } else if (/\s+MX\s+/.test(uRR)) {
          ret.mx = ret.mx || [];
          ret.mx.push(parseMX(rr));
        } else if (/\s+PTR\s+/.test(uRR)) {
          ret.ptr = ret.ptr || [];
          ret.ptr.push(parsePTR(rr, ret.ptr, ret.$origin));
        } else if (/\s+SRV\s+/.test(uRR)) {
          ret.srv = ret.srv || [];
          ret.srv.push(parseSRV(rr));
        } else if (/\s+SPF\s+/.test(uRR)) {
          ret.spf = ret.spf || [];
          ret.spf.push(parseSPF(rr));
        } else if (/\s+URI\s+/.test(uRR)) {
          ret.uri = ret.uri || [];
          ret.uri.push(parseURI(rr));
        }
      }
      return ret;
    }
    function parseSOA(rr) {
      var soa = {};
      var rrTokens = rr.trim().split(/\s+/g);
      var l = rrTokens.length;
      soa.name = rrTokens[0];
      soa.minimum = parseInt(rrTokens[l - 1], 10);
      soa.expire = parseInt(rrTokens[l - 2], 10);
      soa.retry = parseInt(rrTokens[l - 3], 10);
      soa.refresh = parseInt(rrTokens[l - 4], 10);
      soa.serial = parseInt(rrTokens[l - 5], 10);
      soa.rname = rrTokens[l - 6];
      soa.mname = rrTokens[l - 7];
      if (!isNaN(rrTokens[1]))
        soa.ttl = parseInt(rrTokens[1], 10);
      return soa;
    }
    function parseNS(rr) {
      var rrTokens = rr.trim().split(/\s+/g);
      var l = rrTokens.length;
      var result = {
        name: rrTokens[0],
        host: rrTokens[l - 1]
      };
      if (!isNaN(rrTokens[1]))
        result.ttl = parseInt(rrTokens[1], 10);
      return result;
    }
    function parseA(rr, recordsSoFar) {
      var rrTokens = rr.trim().split(/\s+/g);
      var urrTokens = rr.trim().toUpperCase().split(/\s+/g);
      var l = rrTokens.length;
      var result = {
        name: rrTokens[0],
        ip: rrTokens[l - 1]
      };
      if (urrTokens.lastIndexOf("A") === 0) {
        if (recordsSoFar.length) {
          result.name = recordsSoFar[recordsSoFar.length - 1].name;
        } else {
          result.name = "@";
        }
      }
      if (!isNaN(rrTokens[1]))
        result.ttl = parseInt(rrTokens[1], 10);
      return result;
    }
    function parseAAAA(rr) {
      var rrTokens = rr.trim().split(/\s+/g);
      var l = rrTokens.length;
      var result = {
        name: rrTokens[0],
        ip: rrTokens[l - 1]
      };
      if (!isNaN(rrTokens[1]))
        result.ttl = parseInt(rrTokens[1], 10);
      return result;
    }
    function parseCNAME(rr) {
      var rrTokens = rr.trim().split(/\s+/g);
      var l = rrTokens.length;
      var result = {
        name: rrTokens[0],
        alias: rrTokens[l - 1]
      };
      if (!isNaN(rrTokens[1]))
        result.ttl = parseInt(rrTokens[1], 10);
      return result;
    }
    function parseMX(rr) {
      var rrTokens = rr.trim().split(/\s+/g);
      var l = rrTokens.length;
      var result = {
        name: rrTokens[0],
        preference: parseInt(rrTokens[l - 2], 10),
        host: rrTokens[l - 1]
      };
      if (!isNaN(rrTokens[1]))
        result.ttl = parseInt(rrTokens[1], 10);
      return result;
    }
    function parseTXT(rr) {
      var rrTokens = rr.trim().match(/[^\s"']+|"[^"]*"|'[^']*'/g);
      if (!rrTokens)
        throw new Error("Failure to tokenize TXT record");
      var l = rrTokens.length;
      var indexTXT = rrTokens.indexOf("TXT");
      function stripText(txt) {
        if (txt.indexOf('"') > -1) {
          txt = txt.split('"')[1];
        }
        return txt;
      }
      var tokenTxt;
      if (l - indexTXT - 1 > 1) {
        tokenTxt = [].concat(rrTokens.slice(indexTXT + 1).map(stripText));
      } else {
        tokenTxt = stripText(rrTokens[l - 1]);
      }
      var result = {
        name: rrTokens[0],
        txt: tokenTxt
      };
      if (!isNaN(rrTokens[1]))
        result.ttl = parseInt(rrTokens[1], 10);
      return result;
    }
    function parsePTR(rr, recordsSoFar, currentOrigin) {
      var rrTokens = rr.trim().split(/\s+/g);
      var urrTokens = rr.trim().toUpperCase().split(/\s+/g);
      if (urrTokens.lastIndexOf("PTR") === 0 && recordsSoFar[recordsSoFar.length - 1]) {
        rrTokens.unshift(recordsSoFar[recordsSoFar.length - 1].name);
      }
      var l = rrTokens.length;
      var result = {
        name: rrTokens[0],
        fullname: rrTokens[0] + "." + currentOrigin,
        host: rrTokens[l - 1]
      };
      if (!isNaN(rrTokens[1]))
        result.ttl = parseInt(rrTokens[1], 10);
      return result;
    }
    function parseSRV(rr) {
      var rrTokens = rr.trim().split(/\s+/g);
      var l = rrTokens.length;
      var result = {
        name: rrTokens[0],
        target: rrTokens[l - 1],
        priority: parseInt(rrTokens[l - 4], 10),
        weight: parseInt(rrTokens[l - 3], 10),
        port: parseInt(rrTokens[l - 2], 10)
      };
      if (!isNaN(rrTokens[1]))
        result.ttl = parseInt(rrTokens[1], 10);
      return result;
    }
    function parseSPF(rr) {
      var rrTokens = rr.trim().split(/\s+/g);
      var result = {
        name: rrTokens[0],
        data: ""
      };
      var l = rrTokens.length;
      while (l-- > 4) {
        result.data = rrTokens[l] + " " + result.data.trim();
      }
      if (!isNaN(rrTokens[1]))
        result.ttl = parseInt(rrTokens[1], 10);
      return result;
    }
    function parseURI(rr) {
      var rrTokens = rr.trim().split(/\s+/g);
      var l = rrTokens.length;
      var result = {
        name: rrTokens[0],
        target: rrTokens[l - 1].replace(/"/g, ""),
        priority: parseInt(rrTokens[l - 3], 10),
        weight: parseInt(rrTokens[l - 2], 10)
      };
      if (!isNaN(rrTokens[1]))
        result.ttl = parseInt(rrTokens[1], 10);
      return result;
    }
    var ZoneFile = function() {
      function ZoneFile2(zoneFile) {
        if (typeof zoneFile === "object") {
          this.jsonZoneFile = JSON.parse(JSON.stringify(zoneFile));
        } else if (typeof zoneFile === "string") {
          this.jsonZoneFile = parseZoneFile3(zoneFile);
        } else {
          this.jsonZoneFile = void 0;
        }
      }
      var _proto = ZoneFile2.prototype;
      _proto.toJSON = function toJSON() {
        return this.jsonZoneFile;
      };
      _proto.toString = function toString() {
        return makeZoneFile2(this.toJSON());
      };
      return ZoneFile2;
    }();
    exports.ZoneFile = ZoneFile;
    exports.makeZoneFile = makeZoneFile2;
    exports.parseZoneFile = parseZoneFile3;
  }
});

// node_modules/zone-file/dist/index.js
var require_dist = __commonJS({
  "node_modules/zone-file/dist/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_zone_file_cjs_development();
    }
  }
});

// node_modules/async/dist/async.js
var require_async = __commonJS({
  "node_modules/async/dist/async.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.async = global2.async || {});
    })(exports, function(exports2) {
      "use strict";
      function slice(arrayLike, start) {
        start = start | 0;
        var newLen = Math.max(arrayLike.length - start, 0);
        var newArr = Array(newLen);
        for (var idx = 0; idx < newLen; idx++) {
          newArr[idx] = arrayLike[start + idx];
        }
        return newArr;
      }
      var apply = function(fn) {
        var args = slice(arguments, 1);
        return function() {
          var callArgs = slice(arguments);
          return fn.apply(null, args.concat(callArgs));
        };
      };
      var initialParams = function(fn) {
        return function() {
          var args = slice(arguments);
          var callback = args.pop();
          fn.call(this, args, callback);
        };
      };
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
      var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
      function fallback(fn) {
        setTimeout(fn, 0);
      }
      function wrap(defer) {
        return function(fn) {
          var args = slice(arguments, 1);
          defer(function() {
            fn.apply(null, args);
          });
        };
      }
      var _defer;
      if (hasSetImmediate) {
        _defer = setImmediate;
      } else if (hasNextTick) {
        _defer = process.nextTick;
      } else {
        _defer = fallback;
      }
      var setImmediate$1 = wrap(_defer);
      function asyncify(func) {
        return initialParams(function(args, callback) {
          var result;
          try {
            result = func.apply(this, args);
          } catch (e) {
            return callback(e);
          }
          if (isObject(result) && typeof result.then === "function") {
            result.then(function(value) {
              invokeCallback(callback, null, value);
            }, function(err) {
              invokeCallback(callback, err.message ? err : new Error(err));
            });
          } else {
            callback(null, result);
          }
        });
      }
      function invokeCallback(callback, error, value) {
        try {
          callback(error, value);
        } catch (e) {
          setImmediate$1(rethrow, e);
        }
      }
      function rethrow(error) {
        throw error;
      }
      var supportsSymbol = typeof Symbol === "function";
      function isAsync(fn) {
        return supportsSymbol && fn[Symbol.toStringTag] === "AsyncFunction";
      }
      function wrapAsync(asyncFn) {
        return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
      }
      function applyEach$1(eachfn) {
        return function(fns) {
          var args = slice(arguments, 1);
          var go = initialParams(function(args2, callback) {
            var that = this;
            return eachfn(fns, function(fn, cb) {
              wrapAsync(fn).apply(that, args2.concat(cb));
            }, callback);
          });
          if (args.length) {
            return go.apply(this, args);
          } else {
            return go;
          }
        };
      }
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var Symbol$1 = root.Symbol;
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var nativeObjectToString = objectProto.toString;
      var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag$1), tag = value[symToStringTag$1];
        try {
          value[symToStringTag$1] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag$1] = tag;
          } else {
            delete value[symToStringTag$1];
          }
        }
        return result;
      }
      var objectProto$1 = Object.prototype;
      var nativeObjectToString$1 = objectProto$1.toString;
      function objectToString(value) {
        return nativeObjectToString$1.call(value);
      }
      var nullTag = "[object Null]";
      var undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      var asyncTag = "[object AsyncFunction]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var proxyTag = "[object Proxy]";
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      var breakLoop = {};
      function noop() {
      }
      function once(fn) {
        return function() {
          if (fn === null)
            return;
          var callFn = fn;
          fn = null;
          callFn.apply(this, arguments);
        };
      }
      var iteratorSymbol = typeof Symbol === "function" && Symbol.iterator;
      var getIterator = function(coll) {
        return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
      };
      function baseTimes(n, iteratee) {
        var index2 = -1, result = Array(n);
        while (++index2 < n) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var argsTag = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      var objectProto$3 = Object.prototype;
      var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
      var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty$2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray = Array.isArray;
      function stubFalse() {
        return false;
      }
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer = moduleExports ? root.Buffer : void 0;
      var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      var MAX_SAFE_INTEGER$1 = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER$1 : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      var argsTag$1 = "[object Arguments]";
      var arrayTag = "[object Array]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag$1 = "[object Function]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var objectTag = "[object Object]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      var freeExports$1 = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
      var freeProcess = moduleExports$1 && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      var objectProto$2 = Object.prototype;
      var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty$1.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      var objectProto$5 = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$5;
        return value === proto;
      }
      function overArg(func, transform2) {
        return function(arg) {
          return func(transform2(arg));
        };
      }
      var nativeKeys = overArg(Object.keys, Object);
      var objectProto$4 = Object.prototype;
      var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty$3.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function createArrayIterator(coll) {
        var i = -1;
        var len = coll.length;
        return function next() {
          return ++i < len ? { value: coll[i], key: i } : null;
        };
      }
      function createES2015Iterator(iterator2) {
        var i = -1;
        return function next() {
          var item = iterator2.next();
          if (item.done)
            return null;
          i++;
          return { value: item.value, key: i };
        };
      }
      function createObjectIterator(obj) {
        var okeys = keys(obj);
        var i = -1;
        var len = okeys.length;
        return function next() {
          var key = okeys[++i];
          if (key === "__proto__") {
            return next();
          }
          return i < len ? { value: obj[key], key } : null;
        };
      }
      function iterator(coll) {
        if (isArrayLike(coll)) {
          return createArrayIterator(coll);
        }
        var iterator2 = getIterator(coll);
        return iterator2 ? createES2015Iterator(iterator2) : createObjectIterator(coll);
      }
      function onlyOnce(fn) {
        return function() {
          if (fn === null)
            throw new Error("Callback was already called.");
          var callFn = fn;
          fn = null;
          callFn.apply(this, arguments);
        };
      }
      function _eachOfLimit(limit) {
        return function(obj, iteratee, callback) {
          callback = once(callback || noop);
          if (limit <= 0 || !obj) {
            return callback(null);
          }
          var nextElem = iterator(obj);
          var done = false;
          var running = 0;
          var looping = false;
          function iterateeCallback(err, value) {
            running -= 1;
            if (err) {
              done = true;
              callback(err);
            } else if (value === breakLoop || done && running <= 0) {
              done = true;
              return callback(null);
            } else if (!looping) {
              replenish();
            }
          }
          function replenish() {
            looping = true;
            while (running < limit && !done) {
              var elem = nextElem();
              if (elem === null) {
                done = true;
                if (running <= 0) {
                  callback(null);
                }
                return;
              }
              running += 1;
              iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
            }
            looping = false;
          }
          replenish();
        };
      }
      function eachOfLimit(coll, limit, iteratee, callback) {
        _eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
      }
      function doLimit(fn, limit) {
        return function(iterable, iteratee, callback) {
          return fn(iterable, limit, iteratee, callback);
        };
      }
      function eachOfArrayLike(coll, iteratee, callback) {
        callback = once(callback || noop);
        var index2 = 0, completed = 0, length = coll.length;
        if (length === 0) {
          callback(null);
        }
        function iteratorCallback(err, value) {
          if (err) {
            callback(err);
          } else if (++completed === length || value === breakLoop) {
            callback(null);
          }
        }
        for (; index2 < length; index2++) {
          iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
        }
      }
      var eachOfGeneric = doLimit(eachOfLimit, Infinity);
      var eachOf = function(coll, iteratee, callback) {
        var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
        eachOfImplementation(coll, wrapAsync(iteratee), callback);
      };
      function doParallel(fn) {
        return function(obj, iteratee, callback) {
          return fn(eachOf, obj, wrapAsync(iteratee), callback);
        };
      }
      function _asyncMap(eachfn, arr, iteratee, callback) {
        callback = callback || noop;
        arr = arr || [];
        var results = [];
        var counter = 0;
        var _iteratee = wrapAsync(iteratee);
        eachfn(arr, function(value, _, callback2) {
          var index2 = counter++;
          _iteratee(value, function(err, v) {
            results[index2] = v;
            callback2(err);
          });
        }, function(err) {
          callback(err, results);
        });
      }
      var map = doParallel(_asyncMap);
      var applyEach = applyEach$1(map);
      function doParallelLimit(fn) {
        return function(obj, limit, iteratee, callback) {
          return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
        };
      }
      var mapLimit = doParallelLimit(_asyncMap);
      var mapSeries = doLimit(mapLimit, 1);
      var applyEachSeries = applyEach$1(mapSeries);
      function arrayEach(array, iteratee) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (iteratee(array[index2], index2, array) === false) {
            break;
          }
        }
        return array;
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee, keysFunc) {
          var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index2];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      var baseFor = createBaseFor();
      function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys);
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index2-- : ++index2 < length) {
          if (predicate(array[index2], index2, array)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index2 = fromIndex - 1, length = array.length;
        while (++index2 < length) {
          if (array[index2] === value) {
            return index2;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var auto = function(tasks, concurrency, callback) {
        if (typeof concurrency === "function") {
          callback = concurrency;
          concurrency = null;
        }
        callback = once(callback || noop);
        var keys$$1 = keys(tasks);
        var numTasks = keys$$1.length;
        if (!numTasks) {
          return callback(null);
        }
        if (!concurrency) {
          concurrency = numTasks;
        }
        var results = {};
        var runningTasks = 0;
        var hasError = false;
        var listeners = /* @__PURE__ */ Object.create(null);
        var readyTasks = [];
        var readyToCheck = [];
        var uncheckedDependencies = {};
        baseForOwn(tasks, function(task, key) {
          if (!isArray(task)) {
            enqueueTask(key, [task]);
            readyToCheck.push(key);
            return;
          }
          var dependencies = task.slice(0, task.length - 1);
          var remainingDependencies = dependencies.length;
          if (remainingDependencies === 0) {
            enqueueTask(key, task);
            readyToCheck.push(key);
            return;
          }
          uncheckedDependencies[key] = remainingDependencies;
          arrayEach(dependencies, function(dependencyName) {
            if (!tasks[dependencyName]) {
              throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
            }
            addListener(dependencyName, function() {
              remainingDependencies--;
              if (remainingDependencies === 0) {
                enqueueTask(key, task);
              }
            });
          });
        });
        checkForDeadlocks();
        processQueue();
        function enqueueTask(key, task) {
          readyTasks.push(function() {
            runTask(key, task);
          });
        }
        function processQueue() {
          if (readyTasks.length === 0 && runningTasks === 0) {
            return callback(null, results);
          }
          while (readyTasks.length && runningTasks < concurrency) {
            var run = readyTasks.shift();
            run();
          }
        }
        function addListener(taskName, fn) {
          var taskListeners = listeners[taskName];
          if (!taskListeners) {
            taskListeners = listeners[taskName] = [];
          }
          taskListeners.push(fn);
        }
        function taskComplete(taskName) {
          var taskListeners = listeners[taskName] || [];
          arrayEach(taskListeners, function(fn) {
            fn();
          });
          processQueue();
        }
        function runTask(key, task) {
          if (hasError)
            return;
          var taskCallback = onlyOnce(function(err, result) {
            runningTasks--;
            if (arguments.length > 2) {
              result = slice(arguments, 1);
            }
            if (err) {
              var safeResults = {};
              baseForOwn(results, function(val, rkey) {
                safeResults[rkey] = val;
              });
              safeResults[key] = result;
              hasError = true;
              listeners = /* @__PURE__ */ Object.create(null);
              callback(err, safeResults);
            } else {
              results[key] = result;
              taskComplete(key);
            }
          });
          runningTasks++;
          var taskFn = wrapAsync(task[task.length - 1]);
          if (task.length > 1) {
            taskFn(results, taskCallback);
          } else {
            taskFn(taskCallback);
          }
        }
        function checkForDeadlocks() {
          var currentTask;
          var counter = 0;
          while (readyToCheck.length) {
            currentTask = readyToCheck.pop();
            counter++;
            arrayEach(getDependents(currentTask), function(dependent) {
              if (--uncheckedDependencies[dependent] === 0) {
                readyToCheck.push(dependent);
              }
            });
          }
          if (counter !== numTasks) {
            throw new Error(
              "async.auto cannot execute tasks due to a recursive dependency"
            );
          }
        }
        function getDependents(taskName) {
          var result = [];
          baseForOwn(tasks, function(task, key) {
            if (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) {
              result.push(key);
            }
          });
          return result;
        }
      };
      function arrayMap(array, iteratee) {
        var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index2 < length) {
          result[index2] = iteratee(array[index2], index2, array);
        }
        return result;
      }
      var symbolTag = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var INFINITY = 1 / 0;
      var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0;
      var symbolToString = symbolProto ? symbolProto.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function baseSlice(array, start, end) {
        var index2 = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result = Array(length);
        while (++index2 < length) {
          result[index2] = array[index2 + start];
        }
        return result;
      }
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === void 0 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index2 = strSymbols.length;
        while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index2 = -1, length = strSymbols.length;
        while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function asciiToArray(string) {
        return string.split("");
      }
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsZWJ = "\\u200d";
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      var rsAstralRange$1 = "\\ud800-\\udfff";
      var rsComboMarksRange$1 = "\\u0300-\\u036f";
      var reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange$1 = "\\u20d0-\\u20ff";
      var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
      var rsVarRange$1 = "\\ufe0e\\ufe0f";
      var rsAstral = "[" + rsAstralRange$1 + "]";
      var rsCombo = "[" + rsComboRange$1 + "]";
      var rsFitz = "\\ud83c[\\udffb-\\udfff]";
      var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
      var rsNonAstral = "[^" + rsAstralRange$1 + "]";
      var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
      var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
      var rsZWJ$1 = "\\u200d";
      var reOptMod = rsModifier + "?";
      var rsOptVar = "[" + rsVarRange$1 + "]?";
      var rsOptJoin = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
      var rsSeq = rsOptVar + reOptMod + rsOptJoin;
      var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      var reTrim = /^\s+|\s+$/g;
      function trim(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === void 0)) {
          return string.replace(reTrim, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      var FN_ARGS = /^(?:async\s+)?(function)?\s*[^\(]*\(\s*([^\)]*)\)/m;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /(=.+)?(\s*)$/;
      var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
      function parseParams(func) {
        func = func.toString().replace(STRIP_COMMENTS, "");
        func = func.match(FN_ARGS)[2].replace(" ", "");
        func = func ? func.split(FN_ARG_SPLIT) : [];
        func = func.map(function(arg) {
          return trim(arg.replace(FN_ARG, ""));
        });
        return func;
      }
      function autoInject(tasks, callback) {
        var newTasks = {};
        baseForOwn(tasks, function(taskFn, key) {
          var params;
          var fnIsAsync = isAsync(taskFn);
          var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
          if (isArray(taskFn)) {
            params = taskFn.slice(0, -1);
            taskFn = taskFn[taskFn.length - 1];
            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
          } else if (hasNoDeps) {
            newTasks[key] = taskFn;
          } else {
            params = parseParams(taskFn);
            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
              throw new Error("autoInject task functions require explicit parameters.");
            }
            if (!fnIsAsync)
              params.pop();
            newTasks[key] = params.concat(newTask);
          }
          function newTask(results, taskCb) {
            var newArgs = arrayMap(params, function(name) {
              return results[name];
            });
            newArgs.push(taskCb);
            wrapAsync(taskFn).apply(null, newArgs);
          }
        });
        auto(newTasks, callback);
      }
      function DLL() {
        this.head = this.tail = null;
        this.length = 0;
      }
      function setInitial(dll, node) {
        dll.length = 1;
        dll.head = dll.tail = node;
      }
      DLL.prototype.removeLink = function(node) {
        if (node.prev)
          node.prev.next = node.next;
        else
          this.head = node.next;
        if (node.next)
          node.next.prev = node.prev;
        else
          this.tail = node.prev;
        node.prev = node.next = null;
        this.length -= 1;
        return node;
      };
      DLL.prototype.empty = function() {
        while (this.head)
          this.shift();
        return this;
      };
      DLL.prototype.insertAfter = function(node, newNode) {
        newNode.prev = node;
        newNode.next = node.next;
        if (node.next)
          node.next.prev = newNode;
        else
          this.tail = newNode;
        node.next = newNode;
        this.length += 1;
      };
      DLL.prototype.insertBefore = function(node, newNode) {
        newNode.prev = node.prev;
        newNode.next = node;
        if (node.prev)
          node.prev.next = newNode;
        else
          this.head = newNode;
        node.prev = newNode;
        this.length += 1;
      };
      DLL.prototype.unshift = function(node) {
        if (this.head)
          this.insertBefore(this.head, node);
        else
          setInitial(this, node);
      };
      DLL.prototype.push = function(node) {
        if (this.tail)
          this.insertAfter(this.tail, node);
        else
          setInitial(this, node);
      };
      DLL.prototype.shift = function() {
        return this.head && this.removeLink(this.head);
      };
      DLL.prototype.pop = function() {
        return this.tail && this.removeLink(this.tail);
      };
      DLL.prototype.toArray = function() {
        var arr = Array(this.length);
        var curr = this.head;
        for (var idx = 0; idx < this.length; idx++) {
          arr[idx] = curr.data;
          curr = curr.next;
        }
        return arr;
      };
      DLL.prototype.remove = function(testFn) {
        var curr = this.head;
        while (!!curr) {
          var next = curr.next;
          if (testFn(curr)) {
            this.removeLink(curr);
          }
          curr = next;
        }
        return this;
      };
      function queue(worker, concurrency, payload) {
        if (concurrency == null) {
          concurrency = 1;
        } else if (concurrency === 0) {
          throw new Error("Concurrency must not be zero");
        }
        var _worker = wrapAsync(worker);
        var numRunning = 0;
        var workersList = [];
        var processingScheduled = false;
        function _insert(data, insertAtFront, callback) {
          if (callback != null && typeof callback !== "function") {
            throw new Error("task callback must be a function");
          }
          q.started = true;
          if (!isArray(data)) {
            data = [data];
          }
          if (data.length === 0 && q.idle()) {
            return setImmediate$1(function() {
              q.drain();
            });
          }
          for (var i = 0, l = data.length; i < l; i++) {
            var item = {
              data: data[i],
              callback: callback || noop
            };
            if (insertAtFront) {
              q._tasks.unshift(item);
            } else {
              q._tasks.push(item);
            }
          }
          if (!processingScheduled) {
            processingScheduled = true;
            setImmediate$1(function() {
              processingScheduled = false;
              q.process();
            });
          }
        }
        function _next(tasks) {
          return function(err) {
            numRunning -= 1;
            for (var i = 0, l = tasks.length; i < l; i++) {
              var task = tasks[i];
              var index2 = baseIndexOf(workersList, task, 0);
              if (index2 === 0) {
                workersList.shift();
              } else if (index2 > 0) {
                workersList.splice(index2, 1);
              }
              task.callback.apply(task, arguments);
              if (err != null) {
                q.error(err, task.data);
              }
            }
            if (numRunning <= q.concurrency - q.buffer) {
              q.unsaturated();
            }
            if (q.idle()) {
              q.drain();
            }
            q.process();
          };
        }
        var isProcessing = false;
        var q = {
          _tasks: new DLL(),
          concurrency,
          payload,
          saturated: noop,
          unsaturated: noop,
          buffer: concurrency / 4,
          empty: noop,
          drain: noop,
          error: noop,
          started: false,
          paused: false,
          push: function(data, callback) {
            _insert(data, false, callback);
          },
          kill: function() {
            q.drain = noop;
            q._tasks.empty();
          },
          unshift: function(data, callback) {
            _insert(data, true, callback);
          },
          remove: function(testFn) {
            q._tasks.remove(testFn);
          },
          process: function() {
            if (isProcessing) {
              return;
            }
            isProcessing = true;
            while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
              var tasks = [], data = [];
              var l = q._tasks.length;
              if (q.payload)
                l = Math.min(l, q.payload);
              for (var i = 0; i < l; i++) {
                var node = q._tasks.shift();
                tasks.push(node);
                workersList.push(node);
                data.push(node.data);
              }
              numRunning += 1;
              if (q._tasks.length === 0) {
                q.empty();
              }
              if (numRunning === q.concurrency) {
                q.saturated();
              }
              var cb = onlyOnce(_next(tasks));
              _worker(data, cb);
            }
            isProcessing = false;
          },
          length: function() {
            return q._tasks.length;
          },
          running: function() {
            return numRunning;
          },
          workersList: function() {
            return workersList;
          },
          idle: function() {
            return q._tasks.length + numRunning === 0;
          },
          pause: function() {
            q.paused = true;
          },
          resume: function() {
            if (q.paused === false) {
              return;
            }
            q.paused = false;
            setImmediate$1(q.process);
          }
        };
        return q;
      }
      function cargo(worker, payload) {
        return queue(worker, 1, payload);
      }
      var eachOfSeries = doLimit(eachOfLimit, 1);
      function reduce(coll, memo, iteratee, callback) {
        callback = once(callback || noop);
        var _iteratee = wrapAsync(iteratee);
        eachOfSeries(coll, function(x2, i, callback2) {
          _iteratee(memo, x2, function(err, v) {
            memo = v;
            callback2(err);
          });
        }, function(err) {
          callback(err, memo);
        });
      }
      function seq() {
        var _functions = arrayMap(arguments, wrapAsync);
        return function() {
          var args = slice(arguments);
          var that = this;
          var cb = args[args.length - 1];
          if (typeof cb == "function") {
            args.pop();
          } else {
            cb = noop;
          }
          reduce(
            _functions,
            args,
            function(newargs, fn, cb2) {
              fn.apply(that, newargs.concat(function(err) {
                var nextargs = slice(arguments, 1);
                cb2(err, nextargs);
              }));
            },
            function(err, results) {
              cb.apply(that, [err].concat(results));
            }
          );
        };
      }
      var compose = function() {
        return seq.apply(null, slice(arguments).reverse());
      };
      var _concat = Array.prototype.concat;
      var concatLimit = function(coll, limit, iteratee, callback) {
        callback = callback || noop;
        var _iteratee = wrapAsync(iteratee);
        mapLimit(coll, limit, function(val, callback2) {
          _iteratee(val, function(err) {
            if (err)
              return callback2(err);
            return callback2(null, slice(arguments, 1));
          });
        }, function(err, mapResults) {
          var result = [];
          for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
              result = _concat.apply(result, mapResults[i]);
            }
          }
          return callback(err, result);
        });
      };
      var concat = doLimit(concatLimit, Infinity);
      var concatSeries = doLimit(concatLimit, 1);
      var constant = function() {
        var values = slice(arguments);
        var args = [null].concat(values);
        return function() {
          var callback = arguments[arguments.length - 1];
          return callback.apply(this, args);
        };
      };
      function identity(value) {
        return value;
      }
      function _createTester(check, getResult) {
        return function(eachfn, arr, iteratee, cb) {
          cb = cb || noop;
          var testPassed = false;
          var testResult;
          eachfn(arr, function(value, _, callback) {
            iteratee(value, function(err, result) {
              if (err) {
                callback(err);
              } else if (check(result) && !testResult) {
                testPassed = true;
                testResult = getResult(true, value);
                callback(null, breakLoop);
              } else {
                callback();
              }
            });
          }, function(err) {
            if (err) {
              cb(err);
            } else {
              cb(null, testPassed ? testResult : getResult(false));
            }
          });
        };
      }
      function _findGetResult(v, x2) {
        return x2;
      }
      var detect = doParallel(_createTester(identity, _findGetResult));
      var detectLimit = doParallelLimit(_createTester(identity, _findGetResult));
      var detectSeries = doLimit(detectLimit, 1);
      function consoleFunc(name) {
        return function(fn) {
          var args = slice(arguments, 1);
          args.push(function(err) {
            var args2 = slice(arguments, 1);
            if (typeof console === "object") {
              if (err) {
                if (console.error) {
                  console.error(err);
                }
              } else if (console[name]) {
                arrayEach(args2, function(x2) {
                  console[name](x2);
                });
              }
            }
          });
          wrapAsync(fn).apply(null, args);
        };
      }
      var dir = consoleFunc("dir");
      function doDuring(fn, test, callback) {
        callback = onlyOnce(callback || noop);
        var _fn = wrapAsync(fn);
        var _test = wrapAsync(test);
        function next(err) {
          if (err)
            return callback(err);
          var args = slice(arguments, 1);
          args.push(check);
          _test.apply(this, args);
        }
        function check(err, truth) {
          if (err)
            return callback(err);
          if (!truth)
            return callback(null);
          _fn(next);
        }
        check(null, true);
      }
      function doWhilst(iteratee, test, callback) {
        callback = onlyOnce(callback || noop);
        var _iteratee = wrapAsync(iteratee);
        var next = function(err) {
          if (err)
            return callback(err);
          var args = slice(arguments, 1);
          if (test.apply(this, args))
            return _iteratee(next);
          callback.apply(null, [null].concat(args));
        };
        _iteratee(next);
      }
      function doUntil(iteratee, test, callback) {
        doWhilst(iteratee, function() {
          return !test.apply(this, arguments);
        }, callback);
      }
      function during(test, fn, callback) {
        callback = onlyOnce(callback || noop);
        var _fn = wrapAsync(fn);
        var _test = wrapAsync(test);
        function next(err) {
          if (err)
            return callback(err);
          _test(check);
        }
        function check(err, truth) {
          if (err)
            return callback(err);
          if (!truth)
            return callback(null);
          _fn(next);
        }
        _test(check);
      }
      function _withoutIndex(iteratee) {
        return function(value, index2, callback) {
          return iteratee(value, callback);
        };
      }
      function eachLimit(coll, iteratee, callback) {
        eachOf(coll, _withoutIndex(wrapAsync(iteratee)), callback);
      }
      function eachLimit$1(coll, limit, iteratee, callback) {
        _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
      }
      var eachSeries = doLimit(eachLimit$1, 1);
      function ensureAsync(fn) {
        if (isAsync(fn))
          return fn;
        return initialParams(function(args, callback) {
          var sync = true;
          args.push(function() {
            var innerArgs = arguments;
            if (sync) {
              setImmediate$1(function() {
                callback.apply(null, innerArgs);
              });
            } else {
              callback.apply(null, innerArgs);
            }
          });
          fn.apply(this, args);
          sync = false;
        });
      }
      function notId(v) {
        return !v;
      }
      var every = doParallel(_createTester(notId, notId));
      var everyLimit = doParallelLimit(_createTester(notId, notId));
      var everySeries = doLimit(everyLimit, 1);
      function baseProperty(key) {
        return function(object) {
          return object == null ? void 0 : object[key];
        };
      }
      function filterArray(eachfn, arr, iteratee, callback) {
        var truthValues = new Array(arr.length);
        eachfn(arr, function(x2, index2, callback2) {
          iteratee(x2, function(err, v) {
            truthValues[index2] = !!v;
            callback2(err);
          });
        }, function(err) {
          if (err)
            return callback(err);
          var results = [];
          for (var i = 0; i < arr.length; i++) {
            if (truthValues[i])
              results.push(arr[i]);
          }
          callback(null, results);
        });
      }
      function filterGeneric(eachfn, coll, iteratee, callback) {
        var results = [];
        eachfn(coll, function(x2, index2, callback2) {
          iteratee(x2, function(err, v) {
            if (err) {
              callback2(err);
            } else {
              if (v) {
                results.push({ index: index2, value: x2 });
              }
              callback2();
            }
          });
        }, function(err) {
          if (err) {
            callback(err);
          } else {
            callback(null, arrayMap(results.sort(function(a2, b2) {
              return a2.index - b2.index;
            }), baseProperty("value")));
          }
        });
      }
      function _filter(eachfn, coll, iteratee, callback) {
        var filter2 = isArrayLike(coll) ? filterArray : filterGeneric;
        filter2(eachfn, coll, wrapAsync(iteratee), callback || noop);
      }
      var filter = doParallel(_filter);
      var filterLimit = doParallelLimit(_filter);
      var filterSeries = doLimit(filterLimit, 1);
      function forever(fn, errback) {
        var done = onlyOnce(errback || noop);
        var task = wrapAsync(ensureAsync(fn));
        function next(err) {
          if (err)
            return done(err);
          task(next);
        }
        next();
      }
      var groupByLimit = function(coll, limit, iteratee, callback) {
        callback = callback || noop;
        var _iteratee = wrapAsync(iteratee);
        mapLimit(coll, limit, function(val, callback2) {
          _iteratee(val, function(err, key) {
            if (err)
              return callback2(err);
            return callback2(null, { key, val });
          });
        }, function(err, mapResults) {
          var result = {};
          var hasOwnProperty2 = Object.prototype.hasOwnProperty;
          for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
              var key = mapResults[i].key;
              var val = mapResults[i].val;
              if (hasOwnProperty2.call(result, key)) {
                result[key].push(val);
              } else {
                result[key] = [val];
              }
            }
          }
          return callback(err, result);
        });
      };
      var groupBy = doLimit(groupByLimit, Infinity);
      var groupBySeries = doLimit(groupByLimit, 1);
      var log = consoleFunc("log");
      function mapValuesLimit(obj, limit, iteratee, callback) {
        callback = once(callback || noop);
        var newObj = {};
        var _iteratee = wrapAsync(iteratee);
        eachOfLimit(obj, limit, function(val, key, next) {
          _iteratee(val, key, function(err, result) {
            if (err)
              return next(err);
            newObj[key] = result;
            next();
          });
        }, function(err) {
          callback(err, newObj);
        });
      }
      var mapValues = doLimit(mapValuesLimit, Infinity);
      var mapValuesSeries = doLimit(mapValuesLimit, 1);
      function has(obj, key) {
        return key in obj;
      }
      function memoize(fn, hasher) {
        var memo = /* @__PURE__ */ Object.create(null);
        var queues = /* @__PURE__ */ Object.create(null);
        hasher = hasher || identity;
        var _fn = wrapAsync(fn);
        var memoized = initialParams(function memoized2(args, callback) {
          var key = hasher.apply(null, args);
          if (has(memo, key)) {
            setImmediate$1(function() {
              callback.apply(null, memo[key]);
            });
          } else if (has(queues, key)) {
            queues[key].push(callback);
          } else {
            queues[key] = [callback];
            _fn.apply(null, args.concat(function() {
              var args2 = slice(arguments);
              memo[key] = args2;
              var q = queues[key];
              delete queues[key];
              for (var i = 0, l = q.length; i < l; i++) {
                q[i].apply(null, args2);
              }
            }));
          }
        });
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
      }
      var _defer$1;
      if (hasNextTick) {
        _defer$1 = process.nextTick;
      } else if (hasSetImmediate) {
        _defer$1 = setImmediate;
      } else {
        _defer$1 = fallback;
      }
      var nextTick = wrap(_defer$1);
      function _parallel(eachfn, tasks, callback) {
        callback = callback || noop;
        var results = isArrayLike(tasks) ? [] : {};
        eachfn(tasks, function(task, key, callback2) {
          wrapAsync(task)(function(err, result) {
            if (arguments.length > 2) {
              result = slice(arguments, 1);
            }
            results[key] = result;
            callback2(err);
          });
        }, function(err) {
          callback(err, results);
        });
      }
      function parallelLimit(tasks, callback) {
        _parallel(eachOf, tasks, callback);
      }
      function parallelLimit$1(tasks, limit, callback) {
        _parallel(_eachOfLimit(limit), tasks, callback);
      }
      var queue$1 = function(worker, concurrency) {
        var _worker = wrapAsync(worker);
        return queue(function(items, cb) {
          _worker(items[0], cb);
        }, concurrency, 1);
      };
      var priorityQueue = function(worker, concurrency) {
        var q = queue$1(worker, concurrency);
        q.push = function(data, priority, callback) {
          if (callback == null)
            callback = noop;
          if (typeof callback !== "function") {
            throw new Error("task callback must be a function");
          }
          q.started = true;
          if (!isArray(data)) {
            data = [data];
          }
          if (data.length === 0) {
            return setImmediate$1(function() {
              q.drain();
            });
          }
          priority = priority || 0;
          var nextNode = q._tasks.head;
          while (nextNode && priority >= nextNode.priority) {
            nextNode = nextNode.next;
          }
          for (var i = 0, l = data.length; i < l; i++) {
            var item = {
              data: data[i],
              priority,
              callback
            };
            if (nextNode) {
              q._tasks.insertBefore(nextNode, item);
            } else {
              q._tasks.push(item);
            }
          }
          setImmediate$1(q.process);
        };
        delete q.unshift;
        return q;
      };
      function race(tasks, callback) {
        callback = once(callback || noop);
        if (!isArray(tasks))
          return callback(new TypeError("First argument to race must be an array of functions"));
        if (!tasks.length)
          return callback();
        for (var i = 0, l = tasks.length; i < l; i++) {
          wrapAsync(tasks[i])(callback);
        }
      }
      function reduceRight(array, memo, iteratee, callback) {
        var reversed = slice(array).reverse();
        reduce(reversed, memo, iteratee, callback);
      }
      function reflect(fn) {
        var _fn = wrapAsync(fn);
        return initialParams(function reflectOn(args, reflectCallback) {
          args.push(function callback(error, cbArg) {
            if (error) {
              reflectCallback(null, { error });
            } else {
              var value;
              if (arguments.length <= 2) {
                value = cbArg;
              } else {
                value = slice(arguments, 1);
              }
              reflectCallback(null, { value });
            }
          });
          return _fn.apply(this, args);
        });
      }
      function reflectAll(tasks) {
        var results;
        if (isArray(tasks)) {
          results = arrayMap(tasks, reflect);
        } else {
          results = {};
          baseForOwn(tasks, function(task, key) {
            results[key] = reflect.call(this, task);
          });
        }
        return results;
      }
      function reject$1(eachfn, arr, iteratee, callback) {
        _filter(eachfn, arr, function(value, cb) {
          iteratee(value, function(err, v) {
            cb(err, !v);
          });
        }, callback);
      }
      var reject = doParallel(reject$1);
      var rejectLimit = doParallelLimit(reject$1);
      var rejectSeries = doLimit(rejectLimit, 1);
      function constant$1(value) {
        return function() {
          return value;
        };
      }
      function retry(opts, task, callback) {
        var DEFAULT_TIMES = 5;
        var DEFAULT_INTERVAL = 0;
        var options = {
          times: DEFAULT_TIMES,
          intervalFunc: constant$1(DEFAULT_INTERVAL)
        };
        function parseTimes(acc, t) {
          if (typeof t === "object") {
            acc.times = +t.times || DEFAULT_TIMES;
            acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);
            acc.errorFilter = t.errorFilter;
          } else if (typeof t === "number" || typeof t === "string") {
            acc.times = +t || DEFAULT_TIMES;
          } else {
            throw new Error("Invalid arguments for async.retry");
          }
        }
        if (arguments.length < 3 && typeof opts === "function") {
          callback = task || noop;
          task = opts;
        } else {
          parseTimes(options, opts);
          callback = callback || noop;
        }
        if (typeof task !== "function") {
          throw new Error("Invalid arguments for async.retry");
        }
        var _task = wrapAsync(task);
        var attempt = 1;
        function retryAttempt() {
          _task(function(err) {
            if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) {
              setTimeout(retryAttempt, options.intervalFunc(attempt));
            } else {
              callback.apply(null, arguments);
            }
          });
        }
        retryAttempt();
      }
      var retryable = function(opts, task) {
        if (!task) {
          task = opts;
          opts = null;
        }
        var _task = wrapAsync(task);
        return initialParams(function(args, callback) {
          function taskFn(cb) {
            _task.apply(null, args.concat(cb));
          }
          if (opts)
            retry(opts, taskFn, callback);
          else
            retry(taskFn, callback);
        });
      };
      function series(tasks, callback) {
        _parallel(eachOfSeries, tasks, callback);
      }
      var some = doParallel(_createTester(Boolean, identity));
      var someLimit = doParallelLimit(_createTester(Boolean, identity));
      var someSeries = doLimit(someLimit, 1);
      function sortBy(coll, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        map(coll, function(x2, callback2) {
          _iteratee(x2, function(err, criteria) {
            if (err)
              return callback2(err);
            callback2(null, { value: x2, criteria });
          });
        }, function(err, results) {
          if (err)
            return callback(err);
          callback(null, arrayMap(results.sort(comparator), baseProperty("value")));
        });
        function comparator(left, right) {
          var a2 = left.criteria, b2 = right.criteria;
          return a2 < b2 ? -1 : a2 > b2 ? 1 : 0;
        }
      }
      function timeout(asyncFn, milliseconds, info) {
        var fn = wrapAsync(asyncFn);
        return initialParams(function(args, callback) {
          var timedOut = false;
          var timer;
          function timeoutCallback() {
            var name = asyncFn.name || "anonymous";
            var error = new Error('Callback function "' + name + '" timed out.');
            error.code = "ETIMEDOUT";
            if (info) {
              error.info = info;
            }
            timedOut = true;
            callback(error);
          }
          args.push(function() {
            if (!timedOut) {
              callback.apply(null, arguments);
              clearTimeout(timer);
            }
          });
          timer = setTimeout(timeoutCallback, milliseconds);
          fn.apply(null, args);
        });
      }
      var nativeCeil = Math.ceil;
      var nativeMax = Math.max;
      function baseRange(start, end, step, fromRight) {
        var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
        while (length--) {
          result[fromRight ? length : ++index2] = start;
          start += step;
        }
        return result;
      }
      function timeLimit(count, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);
      }
      var times = doLimit(timeLimit, Infinity);
      var timesSeries = doLimit(timeLimit, 1);
      function transform(coll, accumulator, iteratee, callback) {
        if (arguments.length <= 3) {
          callback = iteratee;
          iteratee = accumulator;
          accumulator = isArray(coll) ? [] : {};
        }
        callback = once(callback || noop);
        var _iteratee = wrapAsync(iteratee);
        eachOf(coll, function(v, k2, cb) {
          _iteratee(accumulator, v, k2, cb);
        }, function(err) {
          callback(err, accumulator);
        });
      }
      function tryEach(tasks, callback) {
        var error = null;
        var result;
        callback = callback || noop;
        eachSeries(tasks, function(task, callback2) {
          wrapAsync(task)(function(err, res) {
            if (arguments.length > 2) {
              result = slice(arguments, 1);
            } else {
              result = res;
            }
            error = err;
            callback2(!err);
          });
        }, function() {
          callback(error, result);
        });
      }
      function unmemoize(fn) {
        return function() {
          return (fn.unmemoized || fn).apply(null, arguments);
        };
      }
      function whilst(test, iteratee, callback) {
        callback = onlyOnce(callback || noop);
        var _iteratee = wrapAsync(iteratee);
        if (!test())
          return callback(null);
        var next = function(err) {
          if (err)
            return callback(err);
          if (test())
            return _iteratee(next);
          var args = slice(arguments, 1);
          callback.apply(null, [null].concat(args));
        };
        _iteratee(next);
      }
      function until(test, iteratee, callback) {
        whilst(function() {
          return !test.apply(this, arguments);
        }, iteratee, callback);
      }
      var waterfall = function(tasks, callback) {
        callback = once(callback || noop);
        if (!isArray(tasks))
          return callback(new Error("First argument to waterfall must be an array of functions"));
        if (!tasks.length)
          return callback();
        var taskIndex = 0;
        function nextTask(args) {
          var task = wrapAsync(tasks[taskIndex++]);
          args.push(onlyOnce(next));
          task.apply(null, args);
        }
        function next(err) {
          if (err || taskIndex === tasks.length) {
            return callback.apply(null, arguments);
          }
          nextTask(slice(arguments, 1));
        }
        nextTask([]);
      };
      var index = {
        apply,
        applyEach,
        applyEachSeries,
        asyncify,
        auto,
        autoInject,
        cargo,
        compose,
        concat,
        concatLimit,
        concatSeries,
        constant,
        detect,
        detectLimit,
        detectSeries,
        dir,
        doDuring,
        doUntil,
        doWhilst,
        during,
        each: eachLimit,
        eachLimit: eachLimit$1,
        eachOf,
        eachOfLimit,
        eachOfSeries,
        eachSeries,
        ensureAsync,
        every,
        everyLimit,
        everySeries,
        filter,
        filterLimit,
        filterSeries,
        forever,
        groupBy,
        groupByLimit,
        groupBySeries,
        log,
        map,
        mapLimit,
        mapSeries,
        mapValues,
        mapValuesLimit,
        mapValuesSeries,
        memoize,
        nextTick,
        parallel: parallelLimit,
        parallelLimit: parallelLimit$1,
        priorityQueue,
        queue: queue$1,
        race,
        reduce,
        reduceRight,
        reflect,
        reflectAll,
        reject,
        rejectLimit,
        rejectSeries,
        retry,
        retryable,
        seq,
        series,
        setImmediate: setImmediate$1,
        some,
        someLimit,
        someSeries,
        sortBy,
        timeout,
        times,
        timesLimit: timeLimit,
        timesSeries,
        transform,
        tryEach,
        unmemoize,
        until,
        waterfall,
        whilst,
        // aliases
        all: every,
        allLimit: everyLimit,
        allSeries: everySeries,
        any: some,
        anyLimit: someLimit,
        anySeries: someSeries,
        find: detect,
        findLimit: detectLimit,
        findSeries: detectSeries,
        forEach: eachLimit,
        forEachSeries: eachSeries,
        forEachLimit: eachLimit$1,
        forEachOf: eachOf,
        forEachOfSeries: eachOfSeries,
        forEachOfLimit: eachOfLimit,
        inject: reduce,
        foldl: reduce,
        foldr: reduceRight,
        select: filter,
        selectLimit: filterLimit,
        selectSeries: filterSeries,
        wrapSync: asyncify
      };
      exports2["default"] = index;
      exports2.apply = apply;
      exports2.applyEach = applyEach;
      exports2.applyEachSeries = applyEachSeries;
      exports2.asyncify = asyncify;
      exports2.auto = auto;
      exports2.autoInject = autoInject;
      exports2.cargo = cargo;
      exports2.compose = compose;
      exports2.concat = concat;
      exports2.concatLimit = concatLimit;
      exports2.concatSeries = concatSeries;
      exports2.constant = constant;
      exports2.detect = detect;
      exports2.detectLimit = detectLimit;
      exports2.detectSeries = detectSeries;
      exports2.dir = dir;
      exports2.doDuring = doDuring;
      exports2.doUntil = doUntil;
      exports2.doWhilst = doWhilst;
      exports2.during = during;
      exports2.each = eachLimit;
      exports2.eachLimit = eachLimit$1;
      exports2.eachOf = eachOf;
      exports2.eachOfLimit = eachOfLimit;
      exports2.eachOfSeries = eachOfSeries;
      exports2.eachSeries = eachSeries;
      exports2.ensureAsync = ensureAsync;
      exports2.every = every;
      exports2.everyLimit = everyLimit;
      exports2.everySeries = everySeries;
      exports2.filter = filter;
      exports2.filterLimit = filterLimit;
      exports2.filterSeries = filterSeries;
      exports2.forever = forever;
      exports2.groupBy = groupBy;
      exports2.groupByLimit = groupByLimit;
      exports2.groupBySeries = groupBySeries;
      exports2.log = log;
      exports2.map = map;
      exports2.mapLimit = mapLimit;
      exports2.mapSeries = mapSeries;
      exports2.mapValues = mapValues;
      exports2.mapValuesLimit = mapValuesLimit;
      exports2.mapValuesSeries = mapValuesSeries;
      exports2.memoize = memoize;
      exports2.nextTick = nextTick;
      exports2.parallel = parallelLimit;
      exports2.parallelLimit = parallelLimit$1;
      exports2.priorityQueue = priorityQueue;
      exports2.queue = queue$1;
      exports2.race = race;
      exports2.reduce = reduce;
      exports2.reduceRight = reduceRight;
      exports2.reflect = reflect;
      exports2.reflectAll = reflectAll;
      exports2.reject = reject;
      exports2.rejectLimit = rejectLimit;
      exports2.rejectSeries = rejectSeries;
      exports2.retry = retry;
      exports2.retryable = retryable;
      exports2.seq = seq;
      exports2.series = series;
      exports2.setImmediate = setImmediate$1;
      exports2.some = some;
      exports2.someLimit = someLimit;
      exports2.someSeries = someSeries;
      exports2.sortBy = sortBy;
      exports2.timeout = timeout;
      exports2.times = times;
      exports2.timesLimit = timeLimit;
      exports2.timesSeries = timesSeries;
      exports2.transform = transform;
      exports2.tryEach = tryEach;
      exports2.unmemoize = unmemoize;
      exports2.until = until;
      exports2.waterfall = waterfall;
      exports2.whilst = whilst;
      exports2.all = every;
      exports2.allLimit = everyLimit;
      exports2.allSeries = everySeries;
      exports2.any = some;
      exports2.anyLimit = someLimit;
      exports2.anySeries = someSeries;
      exports2.find = detect;
      exports2.findLimit = detectLimit;
      exports2.findSeries = detectSeries;
      exports2.forEach = eachLimit;
      exports2.forEachSeries = eachSeries;
      exports2.forEachLimit = eachLimit$1;
      exports2.forEachOf = eachOf;
      exports2.forEachOfSeries = eachOfSeries;
      exports2.forEachOfLimit = eachOfLimit;
      exports2.inject = reduce;
      exports2.foldl = reduce;
      exports2.foldr = reduceRight;
      exports2.select = filter;
      exports2.selectLimit = filterLimit;
      exports2.selectSeries = filterSeries;
      exports2.wrapSync = asyncify;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/schema-inspector/lib/schema-inspector.js
var require_schema_inspector = __commonJS({
  "node_modules/schema-inspector/lib/schema-inspector.js"(exports, module) {
    (function() {
      var root = {};
      root.async = typeof __require === "function" ? require_async() : window.async;
      if (typeof root.async !== "object") {
        throw new Error("Module async is required (https://github.com/caolan/async)");
      }
      var async = root.async;
      function _extend(origin, add) {
        if (!add || typeof add !== "object") {
          return origin;
        }
        var keys = Object.keys(add);
        var i = keys.length;
        while (i--) {
          origin[keys[i]] = add[keys[i]];
        }
        return origin;
      }
      function _merge() {
        var ret = {};
        var args = Array.prototype.slice.call(arguments);
        var keys = null;
        var i = null;
        args.forEach(function(arg) {
          if (arg && arg.constructor === Object) {
            keys = Object.keys(arg);
            i = keys.length;
            while (i--) {
              ret[keys[i]] = arg[keys[i]];
            }
          }
        });
        return ret;
      }
      function Customisable() {
        this.custom = {};
        this.extend = function(custom) {
          return _extend(this.custom, custom);
        };
        this.reset = function() {
          this.custom = {};
        };
        this.remove = function(fields) {
          if (!_typeIs.array(fields)) {
            fields = [fields];
          }
          fields.forEach(function(field) {
            delete this.custom[field];
          }, this);
        };
      }
      function Inspection(schema, custom) {
        var _stack = ["@"];
        this._schema = schema;
        this._custom = {};
        if (custom != null) {
          for (var key in custom) {
            if (Object.prototype.hasOwnProperty.call(custom, key)) {
              this._custom["$" + key] = custom[key];
            }
          }
        }
        this._getDepth = function() {
          return _stack.length;
        };
        this._dumpStack = function() {
          return _stack.map(function(i) {
            return i.replace(/^\[/g, "\x1B");
          }).join(".").replace(/\.\u001b\u001c\u001d\u001e/g, "[");
        };
        this._deeperObject = function(name) {
          _stack.push(/^[a-z$_][a-z0-9$_]*$/i.test(name) ? name : '["' + name + '"]');
          return this;
        };
        this._deeperArray = function(i) {
          _stack.push("[" + i + "]");
          return this;
        };
        this._back = function() {
          _stack.pop();
          return this;
        };
      }
      var _typeIs = {
        function: function(element) {
          return typeof element === "function";
        },
        string: function(element) {
          return typeof element === "string";
        },
        number: function(element) {
          return typeof element === "number" && !isNaN(element);
        },
        integer: function(element) {
          return typeof element === "number" && element % 1 === 0;
        },
        NaN: function(element) {
          return typeof element === "number" && isNaN(element);
        },
        boolean: function(element) {
          return typeof element === "boolean";
        },
        null: function(element) {
          return element === null;
        },
        date: function(element) {
          return element != null && element instanceof Date;
        },
        object: function(element) {
          return typeof element === "object" && element != null && element.constructor !== Array;
        },
        array: function(element) {
          return element != null && element.constructor === Array;
        },
        any: function() {
          return true;
        }
      };
      function _simpleType(type, candidate) {
        if (typeof type === "function") {
          return candidate instanceof type;
        }
        type = type in _typeIs ? type : "any";
        return _typeIs[type](candidate);
      }
      function _realType(candidate) {
        for (var i in _typeIs) {
          if (_simpleType(i, candidate)) {
            if (i !== "any" && (i !== "object" || candidate.constructor === Object)) {
              return i;
            }
            return "an instance of " + candidate.constructor.name;
          }
        }
      }
      function getIndexes(a2, value) {
        var indexes = [];
        var i = a2.indexOf(value);
        while (i !== -1) {
          indexes.push(i);
          i = a2.indexOf(value, i + 1);
        }
        return indexes;
      }
      var _formats = {
        void: /^$/,
        url: /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)?(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i,
        "date-time": /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?(Z?|(-|\+)\d{2}:\d{2})$/,
        date: /^\d{4}-\d{2}-\d{2}$/,
        coolDateTime: /^\d{4}(-|\/)\d{2}(-|\/)\d{2}(T| )\d{2}:\d{2}:\d{2}(\.\d{3})?Z?$/,
        time: /^\d{2}\:\d{2}\:\d{2}$/,
        color: /^#([0-9a-f])+$/i,
        // Very flexible regular expression designed to catch only obvious mistakes
        // that a user might make that would have a 100% chance of causing email
        // delivery to the address to fail. The library takes a flexible over
        // strict approach. Users should use this only for basic front end email
        // address validation and perform more strict checking using server-side
        // code after the data has been sent to their server.
        // Sourced from https://www.regular-expressions.info/email.html, modified
        // to allow lowercase characters too.
        email: /^[^@]+@[^.]+\.[a-zA-Z]+$/,
        /* eslint-enable prefer-regex-literals */
        /* eslint-enable quotes */
        numeric: /^[0-9]+$/,
        integer: /^\-?[0-9]+$/,
        decimal: /^\-?[0-9]*\.?[0-9]+$/,
        alpha: /^[a-z]+$/i,
        alphaNumeric: /^[a-z0-9]+$/i,
        alphaDash: /^[a-z0-9_-]+$/i,
        javascript: /^[a-z_\$][a-z0-9_\$]*$/i,
        upperString: /^[A-Z ]*$/,
        lowerString: /^[a-z ]*$/,
        v4uuid: /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12}$/i
      };
      var _validationAttribut = {
        optional: function(schema, candidate) {
          var opt = typeof schema.optional === "boolean" ? schema.optional : schema.optional === "true";
          if (opt === true) {
            return;
          }
          if (typeof candidate === "undefined") {
            this.report("is missing and not optional", null, "optional");
          }
        },
        type: function(schema, candidate) {
          if (typeof candidate === "undefined" || typeof schema.type !== "string" && !(schema.type instanceof Array) && typeof schema.type !== "function") {
            return;
          }
          var types = _typeIs.array(schema.type) ? schema.type : [schema.type];
          var typeIsValid = types.some(function(type) {
            return _simpleType(type, candidate);
          });
          if (!typeIsValid) {
            types = types.map(function(t) {
              return typeof t === "function" ? "an instance of " + t.name : t;
            });
            this.report("must be " + types.join(" or ") + ", but is " + _realType(candidate), null, "type");
          }
        },
        uniqueness: function(schema, candidate) {
          if (typeof schema.uniqueness === "string") {
            schema.uniqueness = schema.uniqueness === "true";
          }
          if (typeof schema.uniqueness !== "boolean" || schema.uniqueness === false || !_typeIs.array(candidate) && typeof candidate !== "string") {
            return;
          }
          var reported = [];
          for (var i = 0; i < candidate.length; i++) {
            if (reported.indexOf(candidate[i]) >= 0) {
              continue;
            }
            var indexes = getIndexes(candidate, candidate[i]);
            if (indexes.length > 1) {
              reported.push(candidate[i]);
              this.report("has value [" + candidate[i] + "] more than once at indexes [" + indexes.join(", ") + "]", null, "uniqueness");
            }
          }
        },
        pattern: function(schema, candidate) {
          var self2 = this;
          var regexs = schema.pattern;
          if (typeof candidate !== "string") {
            return;
          }
          var matches = false;
          if (!_typeIs.array(regexs)) {
            regexs = [regexs];
          }
          regexs.forEach(function(regex) {
            if (typeof regex === "string" && regex in _formats) {
              regex = _formats[regex];
            }
            if (regex instanceof RegExp) {
              if (regex.test(candidate)) {
                matches = true;
              }
            }
          });
          if (!matches) {
            self2.report("must match [" + regexs.join(" or ") + '], but is equal to "' + candidate + '"', null, "pattern");
          }
        },
        validDate: function(schema, candidate) {
          if (String(schema.validDate) === "true" && candidate instanceof Date && isNaN(candidate.getTime())) {
            this.report("must be a valid date", null, "validDate");
          }
        },
        minLength: function(schema, candidate) {
          if (typeof candidate !== "string" && !_typeIs.array(candidate)) {
            return;
          }
          var minLength = Number(schema.minLength);
          if (isNaN(minLength)) {
            return;
          }
          if (candidate.length < minLength) {
            this.report("must be longer than " + minLength + " elements, but it has " + candidate.length, null, "minLength");
          }
        },
        maxLength: function(schema, candidate) {
          if (typeof candidate !== "string" && !_typeIs.array(candidate)) {
            return;
          }
          var maxLength = Number(schema.maxLength);
          if (isNaN(maxLength)) {
            return;
          }
          if (candidate.length > maxLength) {
            this.report("must be shorter than " + maxLength + " elements, but it has " + candidate.length, null, "maxLength");
          }
        },
        exactLength: function(schema, candidate) {
          if (typeof candidate !== "string" && !_typeIs.array(candidate)) {
            return;
          }
          var exactLength = Number(schema.exactLength);
          if (isNaN(exactLength)) {
            return;
          }
          if (candidate.length !== exactLength) {
            this.report("must have exactly " + exactLength + " elements, but it have " + candidate.length, null, "exactLength");
          }
        },
        lt: function(schema, candidate) {
          var limit = Number(schema.lt);
          if (typeof candidate !== "number" || isNaN(limit)) {
            return;
          }
          if (candidate >= limit) {
            this.report("must be less than " + limit + ', but is equal to "' + candidate + '"', null, "lt");
          }
        },
        lte: function(schema, candidate) {
          var limit = Number(schema.lte);
          if (typeof candidate !== "number" || isNaN(limit)) {
            return;
          }
          if (candidate > limit) {
            this.report("must be less than or equal to " + limit + ', but is equal to "' + candidate + '"', null, "lte");
          }
        },
        gt: function(schema, candidate) {
          var limit = Number(schema.gt);
          if (typeof candidate !== "number" || isNaN(limit)) {
            return;
          }
          if (candidate <= limit) {
            this.report("must be greater than " + limit + ', but is equal to "' + candidate + '"', null, "gt");
          }
        },
        gte: function(schema, candidate) {
          var limit = Number(schema.gte);
          if (typeof candidate !== "number" || isNaN(limit)) {
            return;
          }
          if (candidate < limit) {
            this.report("must be greater than or equal to " + limit + ', but is equal to "' + candidate + '"', null, "gte");
          }
        },
        eq: function(schema, candidate) {
          if (typeof candidate !== "number" && typeof candidate !== "string" && typeof candidate !== "boolean") {
            return;
          }
          var limit = schema.eq;
          if (typeof limit !== "number" && typeof limit !== "string" && typeof limit !== "boolean" && !_typeIs.array(limit)) {
            return;
          }
          if (_typeIs.array(limit)) {
            for (var i = 0; i < limit.length; i++) {
              if (candidate === limit[i]) {
                return;
              }
            }
            this.report("must be equal to [" + limit.map(function(l) {
              return '"' + l + '"';
            }).join(" or ") + '], but is equal to "' + candidate + '"', null, "eq");
          } else {
            if (candidate !== limit) {
              this.report('must be equal to "' + limit + '", but is equal to "' + candidate + '"', null, "eq");
            }
          }
        },
        ne: function(schema, candidate) {
          if (typeof candidate !== "number" && typeof candidate !== "string") {
            return;
          }
          var limit = schema.ne;
          if (typeof limit !== "number" && typeof limit !== "string" && !_typeIs.array(limit)) {
            return;
          }
          if (_typeIs.array(limit)) {
            for (var i = 0; i < limit.length; i++) {
              if (candidate === limit[i]) {
                this.report('must not be equal to "' + limit[i] + '"', null, "ne");
                return;
              }
            }
          } else {
            if (candidate === limit) {
              this.report('must not be equal to "' + limit + '"', null, "ne");
            }
          }
        },
        multipleOf: function(schema, candidate) {
          const divisor = Number(schema.multipleOf);
          if (typeof candidate !== "number" || isNaN(divisor)) {
            return;
          }
          if (candidate % divisor !== 0) {
            this.report(candidate + " is not divisible by " + divisor, null, "multipleOf");
          }
        },
        someKeys: function(schema, candidat) {
          var _keys = schema.someKeys;
          if (!_typeIs.object(candidat)) {
            return;
          }
          var valid = _keys.some(function(action) {
            return action in candidat;
          });
          if (!valid) {
            this.report("must have at least key " + _keys.map(function(i) {
              return '"' + i + '"';
            }).join(" or "), null, "someKeys");
          }
        },
        strict: function(schema, candidate) {
          if (typeof schema.strict === "string") {
            schema.strict = schema.strict === "true";
          }
          if (schema.strict !== true || !_typeIs.object(candidate) || !_typeIs.object(schema.properties)) {
            return;
          }
          var self2 = this;
          if (typeof schema.properties["*"] === "undefined") {
            var intruder = Object.keys(candidate).filter(function(key) {
              return typeof schema.properties[key] === "undefined";
            });
            if (intruder.length > 0) {
              var msg = "should not contains " + (intruder.length > 1 ? "properties" : "property") + " [" + intruder.map(function(i) {
                return '"' + i + '"';
              }).join(", ") + "]";
              self2.report(msg, null, "strict");
            }
          }
        },
        exec: function(schema, candidate, callback) {
          var self2 = this;
          if (typeof callback === "function") {
            return this.asyncExec(schema, candidate, callback);
          }
          (_typeIs.array(schema.exec) ? schema.exec : [schema.exec]).forEach(function(exec) {
            if (typeof exec === "function") {
              exec.call(self2, schema, candidate);
            }
          });
        },
        properties: function(schema, candidate, callback) {
          if (typeof callback === "function") {
            return this.asyncProperties(schema, candidate, callback);
          }
          if (!(schema.properties instanceof Object) || !(candidate instanceof Object)) {
            return;
          }
          var properties = schema.properties;
          var i;
          if (properties["*"] != null) {
            for (i in candidate) {
              if (i in properties) {
                continue;
              }
              this._deeperObject(i);
              this._validate(properties["*"], candidate[i]);
              this._back();
            }
          }
          for (i in properties) {
            if (i === "*") {
              continue;
            }
            this._deeperObject(i);
            this._validate(properties[i], candidate[i]);
            this._back();
          }
        },
        items: function(schema, candidate, callback) {
          if (typeof callback === "function") {
            return this.asyncItems(schema, candidate, callback);
          }
          if (!(schema.items instanceof Object) || !(candidate instanceof Object)) {
            return;
          }
          var items = schema.items;
          var i, l;
          if (_typeIs.array(items) && _typeIs.array(candidate)) {
            for (i = 0, l = items.length; i < l; i++) {
              this._deeperArray(i);
              this._validate(items[i], candidate[i]);
              this._back();
            }
          } else {
            for (var key in candidate) {
              if (Object.prototype.hasOwnProperty.call(candidate, key)) {
                this._deeperArray(key);
                this._validate(items, candidate[key]);
                this._back();
              }
            }
          }
        }
      };
      var _asyncValidationAttribut = {
        asyncExec: function(schema, candidate, callback) {
          var self2 = this;
          async.eachSeries(_typeIs.array(schema.exec) ? schema.exec : [schema.exec], function(exec, done) {
            if (typeof exec === "function") {
              if (exec.length > 2) {
                return exec.call(self2, schema, candidate, done);
              }
              exec.call(self2, schema, candidate);
            }
            async.nextTick(done);
          }, callback);
        },
        asyncProperties: function(schema, candidate, callback) {
          if (!(schema.properties instanceof Object) || !_typeIs.object(candidate)) {
            return callback();
          }
          var self2 = this;
          var properties = schema.properties;
          async.series([
            function(next) {
              if (properties["*"] == null) {
                return next();
              }
              async.eachSeries(Object.keys(candidate), function(i, done) {
                if (i in properties) {
                  return async.nextTick(done);
                }
                self2._deeperObject(i);
                self2._asyncValidate(properties["*"], candidate[i], function(err) {
                  self2._back();
                  done(err);
                });
              }, next);
            },
            function(next) {
              async.eachSeries(Object.keys(properties), function(i, done) {
                if (i === "*") {
                  return async.nextTick(done);
                }
                self2._deeperObject(i);
                self2._asyncValidate(properties[i], candidate[i], function(err) {
                  self2._back();
                  done(err);
                });
              }, next);
            }
          ], callback);
        },
        asyncItems: function(schema, candidate, callback) {
          if (!(schema.items instanceof Object) || !(candidate instanceof Object)) {
            return callback();
          }
          var self2 = this;
          var items = schema.items;
          if (_typeIs.array(items) && _typeIs.array(candidate)) {
            async.timesSeries(items.length, function(i, done) {
              self2._deeperArray(i);
              self2._asyncValidate(items[i], candidate[i], function(err, res) {
                self2._back();
                done(err, res);
              });
              self2._back();
            }, callback);
          } else {
            async.eachSeries(Object.keys(candidate), function(key, done) {
              self2._deeperArray(key);
              self2._asyncValidate(items, candidate[key], function(err, res) {
                self2._back();
                done(err, res);
              });
            }, callback);
          }
        }
      };
      function Validation(schema, custom) {
        Inspection.prototype.constructor.call(this, schema, _merge(Validation.custom, custom));
        var _error = [];
        this._basicFields = Object.keys(_validationAttribut);
        this._customFields = Object.keys(this._custom);
        this.origin = null;
        this.report = function(message, code, reason) {
          var newErr = {
            code: code || this.userCode || null,
            reason: reason || "unknown",
            message: this.userError || message || "is invalid",
            property: this.userAlias ? this.userAlias + " (" + this._dumpStack() + ")" : this._dumpStack()
          };
          _error.push(newErr);
          return this;
        };
        this.result = function() {
          return {
            error: _error,
            valid: _error.length === 0,
            format: function() {
              if (this.valid === true) {
                return "Candidate is valid";
              }
              return this.error.map(function(i) {
                return "Property " + i.property + ": " + i.message;
              }).join("\n");
            }
          };
        };
      }
      _extend(Validation.prototype, _validationAttribut);
      _extend(Validation.prototype, _asyncValidationAttribut);
      _extend(Validation, new Customisable());
      Validation.prototype.validate = function(candidate, callback) {
        this.origin = candidate;
        if (typeof callback === "function") {
          var self2 = this;
          return async.nextTick(function() {
            self2._asyncValidate(self2._schema, candidate, function(err) {
              self2.origin = null;
              callback(err, self2.result());
            });
          });
        }
        return this._validate(this._schema, candidate).result();
      };
      Validation.prototype._validate = function(schema, candidate, callback) {
        this.userCode = schema.code || null;
        this.userError = schema.error || null;
        this.userAlias = schema.alias || null;
        this._basicFields.forEach(function(i) {
          if ((i in schema || i === "optional") && typeof this[i] === "function") {
            this[i](schema, candidate);
          }
        }, this);
        this._customFields.forEach(function(i) {
          if (i in schema && typeof this._custom[i] === "function") {
            this._custom[i].call(this, schema, candidate);
          }
        }, this);
        return this;
      };
      Validation.prototype._asyncValidate = function(schema, candidate, callback) {
        var self2 = this;
        this.userCode = schema.code || null;
        this.userError = schema.error || null;
        this.userAlias = schema.alias || null;
        async.series([
          function(next) {
            async.eachSeries(Object.keys(_validationAttribut), function(i, done) {
              async.nextTick(function() {
                if ((i in schema || i === "optional") && typeof self2[i] === "function") {
                  if (self2[i].length > 2) {
                    return self2[i](schema, candidate, done);
                  }
                  self2[i](schema, candidate);
                }
                done();
              });
            }, next);
          },
          function(next) {
            async.eachSeries(Object.keys(self2._custom), function(i, done) {
              async.nextTick(function() {
                if (i in schema && typeof self2._custom[i] === "function") {
                  if (self2._custom[i].length > 2) {
                    return self2._custom[i].call(self2, schema, candidate, done);
                  }
                  self2._custom[i].call(self2, schema, candidate);
                }
                done();
              });
            }, next);
          }
        ], callback);
      };
      var _forceType = {
        number: function(post, schema) {
          var n;
          if (typeof post === "number") {
            return post;
          } else if (post === "") {
            if (typeof schema.def !== "undefined") {
              return schema.def;
            }
            return null;
          } else if (typeof post === "string") {
            n = parseFloat(post.replace(/,/g, ".").replace(/ /g, ""));
            if (typeof n === "number") {
              return n;
            }
          } else if (post instanceof Date) {
            return +post;
          }
          return null;
        },
        integer: function(post, schema) {
          var n;
          if (typeof post === "number" && post % 1 === 0) {
            return post;
          } else if (post === "") {
            if (typeof schema.def !== "undefined") {
              return schema.def;
            }
            return null;
          } else if (typeof post === "string") {
            n = parseInt(post.replace(/ /g, ""), 10);
            if (typeof n === "number") {
              return n;
            }
          } else if (typeof post === "number") {
            return parseInt(post, 10);
          } else if (typeof post === "boolean") {
            if (post) {
              return 1;
            }
            return 0;
          } else if (post instanceof Date) {
            return +post;
          }
          return null;
        },
        string: function(post, schema) {
          if (typeof post === "boolean" || typeof post === "number" || post instanceof Date) {
            return post.toString();
          } else if (_typeIs.array(post)) {
            if (schema.items || schema.properties) {
              return post;
            }
            return post.join(String(schema.joinWith || ","));
          } else if (post instanceof Object) {
            if (schema.items || schema.properties) {
              return post;
            }
            return JSON.stringify(post);
          } else if (typeof post === "string" && post.length) {
            return post;
          }
          return null;
        },
        date: function(post, schema) {
          if (post instanceof Date) {
            return post;
          } else {
            var d2 = new Date(post);
            if (!isNaN(d2.getTime())) {
              return d2;
            }
          }
          return null;
        },
        boolean: function(post, schema) {
          if (typeof post === "undefined")
            return null;
          if (typeof post === "string" && post.toLowerCase() === "false")
            return false;
          return !!post;
        },
        object: function(post, schema) {
          if (typeof post !== "string" || _typeIs.object(post)) {
            return post;
          }
          try {
            return JSON.parse(post);
          } catch (e) {
            return null;
          }
        },
        array: function(post, schema) {
          if (_typeIs.array(post)) {
            return post;
          }
          if (typeof post === "undefined") {
            return null;
          }
          if (typeof post === "string") {
            if (post.substring(0, 1) === "[" && post.slice(-1) === "]") {
              try {
                return JSON.parse(post);
              } catch (e) {
                return null;
              }
            }
            return post.split(String(schema.splitWith || ","));
          }
          if (!_typeIs.array(post)) {
            return [post];
          }
          return null;
        }
      };
      var _applyRules = {
        upper: function(post) {
          return post.toUpperCase();
        },
        lower: function(post) {
          return post.toLowerCase();
        },
        title: function(post) {
          return post.replace(/\S*/g, function(txt) {
            return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
          });
        },
        capitalize: function(post) {
          return post.charAt(0).toUpperCase() + post.substr(1).toLowerCase();
        },
        ucfirst: function(post) {
          return post.charAt(0).toUpperCase() + post.substr(1);
        },
        trim: function(post) {
          return post.trim();
        }
      };
      var _sanitizationAttribut = {
        strict: function(schema, post) {
          if (typeof schema.strict === "string") {
            schema.strict = schema.strict === "true";
          }
          if (schema.strict !== true) {
            return post;
          }
          if (!_typeIs.object(schema.properties)) {
            return post;
          }
          if (!_typeIs.object(post)) {
            return post;
          }
          Object.keys(post).forEach(function(key) {
            if (!(key in schema.properties)) {
              delete post[key];
            }
          });
          return post;
        },
        optional: function(schema, post) {
          var opt = typeof schema.optional === "boolean" ? schema.optional : schema.optional !== "false";
          if (opt === true) {
            return post;
          }
          if (typeof post !== "undefined") {
            return post;
          }
          this.report();
          if (schema.def === Date) {
            return /* @__PURE__ */ new Date();
          }
          return schema.def;
        },
        type: function(schema, post) {
          if (typeof schema.type !== "string" || typeof _forceType[schema.type] !== "function") {
            return post;
          }
          var n;
          var opt = typeof schema.optional === "boolean" ? schema.optional : true;
          if (typeof _forceType[schema.type] === "function") {
            n = _forceType[schema.type](post, schema);
            if (n === null && !opt || !n && isNaN(n) || n === null && schema.type === "string") {
              n = schema.def;
            }
          } else if (!opt) {
            n = schema.def;
          }
          if ((n != null || typeof schema.def !== "undefined" && schema.def === n) && n !== post) {
            this.report();
            return n;
          }
          return post;
        },
        rules: function(schema, post) {
          var rules = schema.rules;
          if (typeof post !== "string" || typeof rules !== "string" && !_typeIs.array(rules)) {
            return post;
          }
          var modified = false;
          (_typeIs.array(rules) ? rules : [rules]).forEach(function(rule) {
            if (typeof _applyRules[rule] === "function") {
              post = _applyRules[rule](post);
              modified = true;
            }
          });
          if (modified) {
            this.report();
          }
          return post;
        },
        min: function(schema, post) {
          var postTest = Number(post);
          if (isNaN(postTest)) {
            return post;
          }
          var min = Number(schema.min);
          if (isNaN(min)) {
            return post;
          }
          if (postTest < min) {
            this.report();
            return min;
          }
          return post;
        },
        max: function(schema, post) {
          var postTest = Number(post);
          if (isNaN(postTest)) {
            return post;
          }
          var max = Number(schema.max);
          if (isNaN(max)) {
            return post;
          }
          if (postTest > max) {
            this.report();
            return max;
          }
          return post;
        },
        minLength: function(schema, post) {
          var limit = Number(schema.minLength);
          if (typeof post !== "string" || isNaN(limit) || limit < 0) {
            return post;
          }
          var str = "";
          var gap = limit - post.length;
          if (gap > 0) {
            for (var i = 0; i < gap; i++) {
              str += "-";
            }
            this.report();
            return post + str;
          }
          return post;
        },
        maxLength: function(schema, post) {
          var limit = Number(schema.maxLength);
          if (typeof post !== "string" || isNaN(limit) || limit < 0) {
            return post;
          }
          if (post.length > limit) {
            this.report();
            return post.slice(0, limit);
          }
          return post;
        },
        properties: function(schema, post, callback) {
          if (typeof callback === "function") {
            return this.asyncProperties(schema, post, callback);
          }
          if (!post || typeof post !== "object") {
            return post;
          }
          var properties = schema.properties;
          var tmp;
          var i;
          if (typeof properties["*"] !== "undefined") {
            for (i in post) {
              if (i in properties) {
                continue;
              }
              this._deeperObject(i);
              tmp = this._sanitize(properties["*"], post[i]);
              if (typeof tmp !== "undefined" || "exec" in properties["*"]) {
                post[i] = tmp;
              }
              this._back();
            }
          }
          for (i in properties) {
            if (i !== "*") {
              this._deeperObject(i);
              tmp = this._sanitize(properties[i], post[i]);
              if (typeof tmp !== "undefined" || "exec" in properties[i]) {
                post[i] = tmp;
              }
              this._back();
            }
          }
          return post;
        },
        items: function(schema, post, callback) {
          if (typeof callback === "function") {
            return this.asyncItems(schema, post, callback);
          }
          if (!(schema.items instanceof Object) || !(post instanceof Object)) {
            return post;
          }
          var i;
          if (_typeIs.array(schema.items) && _typeIs.array(post)) {
            var minLength = schema.items.length < post.length ? schema.items.length : post.length;
            for (i = 0; i < minLength; i++) {
              this._deeperArray(i);
              post[i] = this._sanitize(schema.items[i], post[i]);
              this._back();
            }
          } else {
            for (i in post) {
              if (Object.prototype.hasOwnProperty.call(post, i)) {
                this._deeperArray(i);
                post[i] = this._sanitize(schema.items, post[i]);
                this._back();
              }
            }
          }
          return post;
        },
        exec: function(schema, post, callback) {
          if (typeof callback === "function") {
            return this.asyncExec(schema, post, callback);
          }
          var execs = _typeIs.array(schema.exec) ? schema.exec : [schema.exec];
          execs.forEach(function(exec) {
            if (typeof exec === "function") {
              post = exec.call(this, schema, post);
            }
          }, this);
          return post;
        }
      };
      var _asyncSanitizationAttribut = {
        asyncExec: function(schema, post, callback) {
          var self2 = this;
          var execs = _typeIs.array(schema.exec) ? schema.exec : [schema.exec];
          async.eachSeries(execs, function(exec, done) {
            if (typeof exec === "function") {
              if (exec.length > 2) {
                return exec.call(self2, schema, post, function(err, res) {
                  if (err) {
                    return done(err);
                  }
                  post = res;
                  done();
                });
              }
              post = exec.call(self2, schema, post);
            }
            done();
          }, function(err) {
            callback(err, post);
          });
        },
        asyncProperties: function(schema, post, callback) {
          if (!post || typeof post !== "object") {
            return callback(null, post);
          }
          var self2 = this;
          var properties = schema.properties;
          async.series([
            function(next) {
              if (properties["*"] == null) {
                return next();
              }
              var globing = properties["*"];
              async.eachSeries(Object.keys(post), function(i, next2) {
                if (i in properties) {
                  return next2();
                }
                self2._deeperObject(i);
                self2._asyncSanitize(globing, post[i], function(err, res) {
                  if (err) {
                  }
                  if (typeof res !== "undefined") {
                    post[i] = res;
                  }
                  self2._back();
                  next2();
                });
              }, next);
            },
            function(next) {
              async.eachSeries(Object.keys(properties), function(i, next2) {
                if (i === "*") {
                  return next2();
                }
                self2._deeperObject(i);
                self2._asyncSanitize(properties[i], post[i], function(err, res) {
                  if (err) {
                    return next2(err);
                  }
                  if (typeof res !== "undefined") {
                    post[i] = res;
                  }
                  self2._back();
                  next2();
                });
              }, next);
            }
          ], function(err) {
            return callback(err, post);
          });
        },
        asyncItems: function(schema, post, callback) {
          if (!(schema.items instanceof Object) || !(post instanceof Object)) {
            return callback(null, post);
          }
          var self2 = this;
          var items = schema.items;
          if (_typeIs.array(items) && _typeIs.array(post)) {
            var minLength = items.length < post.length ? items.length : post.length;
            async.timesSeries(minLength, function(i, next) {
              self2._deeperArray(i);
              self2._asyncSanitize(items[i], post[i], function(err, res) {
                if (err) {
                  return next(err);
                }
                post[i] = res;
                self2._back();
                next();
              });
            }, function(err) {
              callback(err, post);
            });
          } else {
            async.eachSeries(Object.keys(post), function(key, next) {
              self2._deeperArray(key);
              self2._asyncSanitize(items, post[key], function(err, res) {
                if (err) {
                  return next();
                }
                post[key] = res;
                self2._back();
                next();
              });
            }, function(err) {
              callback(err, post);
            });
          }
          return post;
        }
      };
      function Sanitization(schema, custom) {
        Inspection.prototype.constructor.call(this, schema, _merge(Sanitization.custom, custom));
        var _reporting = [];
        this._basicFields = Object.keys(_sanitizationAttribut);
        this._customFields = Object.keys(this._custom);
        this.origin = null;
        this.report = function(message) {
          var newNot = {
            message: message || "was sanitized",
            property: this.userAlias ? this.userAlias + " (" + this._dumpStack() + ")" : this._dumpStack()
          };
          if (!_reporting.some(function(e) {
            return e.property === newNot.property;
          })) {
            _reporting.push(newNot);
          }
        };
        this.result = function(data) {
          return {
            data,
            reporting: _reporting,
            format: function() {
              return this.reporting.map(function(i) {
                return "Property " + i.property + " " + i.message;
              }).join("\n");
            }
          };
        };
      }
      _extend(Sanitization.prototype, _sanitizationAttribut);
      _extend(Sanitization.prototype, _asyncSanitizationAttribut);
      _extend(Sanitization, new Customisable());
      Sanitization.prototype.sanitize = function(post, callback) {
        this.origin = post;
        if (typeof callback === "function") {
          var self2 = this;
          return this._asyncSanitize(this._schema, post, function(err, data2) {
            self2.origin = null;
            callback(err, self2.result(data2));
          });
        }
        var data = this._sanitize(this._schema, post);
        this.origin = null;
        return this.result(data);
      };
      Sanitization.prototype._sanitize = function(schema, post) {
        this.userAlias = schema.alias || null;
        this._basicFields.forEach(function(i) {
          if ((i in schema || i === "optional") && typeof this[i] === "function") {
            post = this[i](schema, post);
          }
        }, this);
        this._customFields.forEach(function(i) {
          if (i in schema && typeof this._custom[i] === "function") {
            post = this._custom[i].call(this, schema, post);
          }
        }, this);
        return post;
      };
      Sanitization.prototype._asyncSanitize = function(schema, post, callback) {
        var self2 = this;
        this.userAlias = schema.alias || null;
        async.waterfall([
          function(next) {
            async.reduce(self2._basicFields, post, function(value, i, next2) {
              async.nextTick(function() {
                if ((i in schema || i === "optional") && typeof self2[i] === "function") {
                  if (self2[i].length > 2) {
                    return self2[i](schema, value, next2);
                  }
                  value = self2[i](schema, value);
                }
                next2(null, value);
              });
            }, next);
          },
          function(inter, next) {
            async.reduce(self2._customFields, inter, function(value, i, next2) {
              async.nextTick(function() {
                if (i in schema && typeof self2._custom[i] === "function") {
                  if (self2._custom[i].length > 2) {
                    return self2._custom[i].call(self2, schema, value, next2);
                  }
                  value = self2._custom[i].call(self2, schema, value);
                }
                next2(null, value);
              });
            }, next);
          }
        ], callback);
      };
      var INT_MIN = -2147483648;
      var INT_MAX = 2147483647;
      var _rand = {
        int: function(min, max) {
          return min + (0 | Math.random() * (max - min + 1));
        },
        float: function(min, max) {
          return Math.random() * (max - min) + min;
        },
        bool: function() {
          return Math.random() > 0.5;
        },
        char: function(min, max) {
          return String.fromCharCode(this.int(min, max));
        },
        fromList: function(list) {
          return list[this.int(0, list.length - 1)];
        }
      };
      var _formatSample = {
        "date-time": function() {
          return (/* @__PURE__ */ new Date()).toISOString();
        },
        date: function() {
          return (/* @__PURE__ */ new Date()).toISOString().replace(/T.*$/, "");
        },
        time: function() {
          return (/* @__PURE__ */ new Date()).toLocaleTimeString({}, { hour12: false });
        },
        color: function(min, max) {
          var s = "#";
          if (min < 1) {
            min = 1;
          }
          for (var i = 0, l = _rand.int(min, max); i < l; i++) {
            s += _rand.fromList("0123456789abcdefABCDEF");
          }
          return s;
        },
        numeric: function() {
          return "" + _rand.int(0, INT_MAX);
        },
        integer: function() {
          if (_rand.bool() === true) {
            return "-" + this.numeric();
          }
          return this.numeric();
        },
        decimal: function() {
          return this.integer() + "." + this.numeric();
        },
        alpha: function(min, max) {
          var s = "";
          if (min < 1) {
            min = 1;
          }
          for (var i = 0, l = _rand.int(min, max); i < l; i++) {
            s += _rand.fromList("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
          }
          return s;
        },
        alphaNumeric: function(min, max) {
          var s = "";
          if (min < 1) {
            min = 1;
          }
          for (var i = 0, l = _rand.int(min, max); i < l; i++) {
            s += _rand.fromList("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");
          }
          return s;
        },
        alphaDash: function(min, max) {
          var s = "";
          if (min < 1) {
            min = 1;
          }
          for (var i = 0, l = _rand.int(min, max); i < l; i++) {
            s += _rand.fromList("_-abcdefghijklmnopqrstuvwxyz_-ABCDEFGHIJKLMNOPQRSTUVWXYZ_-0123456789_-");
          }
          return s;
        },
        javascript: function(min, max) {
          var s = _rand.fromList("_$abcdefghijklmnopqrstuvwxyz_$ABCDEFGHIJKLMNOPQRSTUVWXYZ_$");
          for (var i = 0, l = _rand.int(min, max - 1); i < l; i++) {
            s += _rand.fromList("_$abcdefghijklmnopqrstuvwxyz_$ABCDEFGHIJKLMNOPQRSTUVWXYZ_$0123456789_$");
          }
          return s;
        }
      };
      function _getLimits(schema) {
        var min = INT_MIN;
        var max = INT_MAX;
        if (schema.gte != null) {
          min = schema.gte;
        } else if (schema.gt != null) {
          min = schema.gt + 1;
        }
        if (schema.lte != null) {
          max = schema.lte;
        } else if (schema.lt != null) {
          max = schema.lt - 1;
        }
        return { min, max };
      }
      var _typeGenerator = {
        string: function(schema) {
          if (schema.eq != null) {
            return schema.eq;
          }
          var s = "";
          var minLength = schema.minLength != null ? schema.minLength : 0;
          var maxLength = schema.maxLength != null ? schema.maxLength : 32;
          if (typeof schema.pattern === "string" && typeof _formatSample[schema.pattern] === "function") {
            return _formatSample[schema.pattern](minLength, maxLength);
          }
          var l = schema.exactLength != null ? schema.exactLength : _rand.int(minLength, maxLength);
          for (var i = 0; i < l; i++) {
            s += _rand.char(32, 126);
          }
          return s;
        },
        number: function(schema) {
          if (schema.eq != null) {
            return schema.eq;
          }
          var limit = _getLimits(schema);
          var n = _rand.float(limit.min, limit.max);
          if (schema.ne != null) {
            var ne = _typeIs.array(schema.ne) ? schema.ne : [schema.ne];
            while (ne.indexOf(n) !== -1) {
              n = _rand.float(limit.min, limit.max);
            }
          }
          return n;
        },
        integer: function(schema) {
          if (schema.eq != null) {
            return schema.eq;
          }
          var limit = _getLimits(schema);
          var n = _rand.int(limit.min, limit.max);
          if (schema.ne != null) {
            var ne = _typeIs.array(schema.ne) ? schema.ne : [schema.ne];
            while (ne.indexOf(n) !== -1) {
              n = _rand.int(limit.min, limit.max);
            }
          }
          return n;
        },
        boolean: function(schema) {
          if (schema.eq != null) {
            return schema.eq;
          }
          return _rand.bool();
        },
        null: function(schema) {
          return null;
        },
        date: function(schema) {
          if (schema.eq != null) {
            return schema.eq;
          }
          return /* @__PURE__ */ new Date();
        },
        object: function(schema) {
          var o = {};
          var prop = schema.properties || {};
          for (var key in prop) {
            if (Object.prototype.hasOwnProperty.call(prop, key)) {
              if (prop[key].optional === true && _rand.bool() === true) {
                continue;
              }
              if (key !== "*") {
                o[key] = this.generate(prop[key]);
              } else {
                var rk = "__random_key_";
                var randomKey = rk + 0;
                var n = _rand.int(1, 9);
                for (var i = 1; i <= n; i++) {
                  if (!(randomKey in prop)) {
                    o[randomKey] = this.generate(prop[key]);
                  }
                  randomKey = rk + i;
                }
              }
            }
          }
          return o;
        },
        array: function(schema) {
          var self2 = this;
          var items = schema.items || {};
          var minLength = schema.minLength != null ? schema.minLength : 0;
          var maxLength = schema.maxLength != null ? schema.maxLength : 16;
          var type;
          var candidate;
          var size;
          var i;
          if (_typeIs.array(items)) {
            size = items.length;
            if (schema.exactLength != null) {
              size = schema.exactLength;
            } else if (size < minLength) {
              size = minLength;
            } else if (size > maxLength) {
              size = maxLength;
            }
            candidate = new Array(size);
            type = null;
            for (i = 0; i < size; i++) {
              type = items[i].type || "any";
              if (_typeIs.array(type)) {
                type = type[_rand.int(0, type.length - 1)];
              }
              candidate[i] = self2[type](items[i]);
            }
          } else {
            size = schema.exactLength != null ? schema.exactLength : _rand.int(minLength, maxLength);
            candidate = new Array(size);
            type = items.type || "any";
            if (_typeIs.array(type)) {
              type = type[_rand.int(0, type.length - 1)];
            }
            for (i = 0; i < size; i++) {
              candidate[i] = self2[type](items);
            }
          }
          return candidate;
        },
        any: function(schema) {
          var fields = Object.keys(_typeGenerator);
          var i = fields[_rand.int(0, fields.length - 2)];
          return this[i](schema);
        }
      };
      function CandidateGenerator() {
      }
      _extend(CandidateGenerator.prototype, _typeGenerator);
      var _instance = null;
      CandidateGenerator.instance = function() {
        if (!(_instance instanceof CandidateGenerator)) {
          _instance = new CandidateGenerator();
        }
        return _instance;
      };
      CandidateGenerator.prototype.generate = function(schema) {
        var type = schema.type || "any";
        if (_typeIs.array(type)) {
          type = type[_rand.int(0, type.length - 1)];
        }
        return this[type](schema);
      };
      var SchemaInspector = {};
      if (typeof module !== "undefined" && module.exports) {
        module.exports = SchemaInspector;
      } else {
        window.SchemaInspector = SchemaInspector;
      }
      SchemaInspector.newSanitization = function(schema, custom) {
        return new Sanitization(schema, custom);
      };
      SchemaInspector.newValidation = function(schema, custom) {
        return new Validation(schema, custom);
      };
      SchemaInspector.Validation = Validation;
      SchemaInspector.Sanitization = Sanitization;
      SchemaInspector.sanitize = function(schema, post, custom, callback) {
        if (arguments.length === 3 && typeof custom === "function") {
          callback = custom;
          custom = null;
        }
        return new Sanitization(schema, custom).sanitize(post, callback);
      };
      SchemaInspector.validate = function(schema, candidate, custom, callback) {
        if (arguments.length === 3 && typeof custom === "function") {
          callback = custom;
          custom = null;
        }
        return new Validation(schema, custom).validate(candidate, callback);
      };
      SchemaInspector.generate = function(schema, n) {
        if (typeof n === "number") {
          var r = new Array(n);
          for (var i = 0; i < n; i++) {
            r[i] = CandidateGenerator.instance().generate(schema);
          }
          return r;
        }
        return CandidateGenerator.instance().generate(schema);
      };
    })();
  }
});

// node_modules/schema-inspector/index.js
var require_schema_inspector2 = __commonJS({
  "node_modules/schema-inspector/index.js"(exports, module) {
    module.exports = require_schema_inspector();
  }
});

// node_modules/@stacks/auth/dist/esm/constants.js
var BLOCKSTACK_HANDLER2 = "blockstack";
var BLOCKSTACK_STORAGE_LABEL = "blockstack";
var DEFAULT_BLOCKSTACK_HOST = "https://browser.blockstack.org/auth";
var DEFAULT_PROFILE = {
  "@type": "Person",
  "@context": "http://schema.org"
};
var DEFAULT_SCOPE = ["store_write"];
var BLOCKSTACK_APP_PRIVATE_KEY_LABEL = "blockstack-transit-private-key";
var DEFAULT_CORE_NODE = "https://stacks-node-api.stacks.co";
var NAME_LOOKUP_PATH = "/v1/names";
var LOCALSTORAGE_SESSION_KEY = "blockstack-session";

// node_modules/@stacks/auth/dist/esm/appConfig.js
var AppConfig = class {
  constructor(scopes = DEFAULT_SCOPE.slice(), appDomain = ((_a) => (_a = getGlobalObject("location", { returnEmptyObject: true })) == null ? void 0 : _a.origin)(), redirectPath = "", manifestPath = "/manifest.json", coreNode = void 0, authenticatorURL = DEFAULT_BLOCKSTACK_HOST) {
    this.appDomain = appDomain;
    this.scopes = scopes;
    this.redirectPath = redirectPath;
    this.manifestPath = manifestPath;
    this.coreNode = coreNode;
    this.authenticatorURL = authenticatorURL;
  }
  redirectURI() {
    return `${this.appDomain}${this.redirectPath}`;
  }
  manifestURI() {
    return `${this.appDomain}${this.manifestPath}`;
  }
};

// node_modules/@stacks/encryption/dist/esm/ec.js
var import_base64_js = __toESM(require_base64_js());

// node_modules/@stacks/encryption/dist/esm/cryptoUtils.js
function isSubtleCryptoAvailable() {
  return typeof crypto !== "undefined" && typeof crypto.subtle !== "undefined";
}
var NO_CRYPTO_LIB = 'Crypto lib not found. Either the WebCrypto "crypto.subtle" or Node.js "crypto" module must be available.';
async function getCryptoLib() {
  if (isSubtleCryptoAvailable()) {
    return {
      lib: crypto.subtle,
      name: "subtleCrypto"
    };
  } else {
    try {
      const nodeCrypto = require_crypto();
      return {
        lib: nodeCrypto,
        name: "nodeCrypto"
      };
    } catch (error) {
      throw new Error(NO_CRYPTO_LIB);
    }
  }
}

// node_modules/@stacks/encryption/dist/esm/aesCipher.js
var NodeCryptoAesCipher = class {
  constructor(createCipher2, createDecipher) {
    this.createCipher = createCipher2;
    this.createDecipher = createDecipher;
  }
  async encrypt(algorithm, key, iv, data) {
    if (algorithm !== "aes-128-cbc" && algorithm !== "aes-256-cbc") {
      throw new Error(`Unsupported cipher algorithm "${algorithm}"`);
    }
    const cipher = this.createCipher(algorithm, key, iv);
    const result = new Uint8Array(concatBytes(cipher.update(data), cipher.final()));
    return Promise.resolve(result);
  }
  async decrypt(algorithm, key, iv, data) {
    if (algorithm !== "aes-128-cbc" && algorithm !== "aes-256-cbc") {
      throw new Error(`Unsupported cipher algorithm "${algorithm}"`);
    }
    const cipher = this.createDecipher(algorithm, key, iv);
    const result = new Uint8Array(concatBytes(cipher.update(data), cipher.final()));
    return Promise.resolve(result);
  }
};
var WebCryptoAesCipher = class {
  constructor(subtleCrypto) {
    this.subtleCrypto = subtleCrypto;
  }
  async encrypt(algorithm, key, iv, data) {
    let algo;
    let length;
    if (algorithm === "aes-128-cbc") {
      algo = "AES-CBC";
      length = 128;
    } else if (algorithm === "aes-256-cbc") {
      algo = "AES-CBC";
      length = 256;
    } else {
      throw new Error(`Unsupported cipher algorithm "${algorithm}"`);
    }
    const cryptoKey = await this.subtleCrypto.importKey("raw", key, { name: algo, length }, false, [
      "encrypt"
    ]);
    const result = await this.subtleCrypto.encrypt({ name: algo, iv }, cryptoKey, data);
    return new Uint8Array(result);
  }
  async decrypt(algorithm, key, iv, data) {
    let algo;
    let length;
    if (algorithm === "aes-128-cbc") {
      algo = "AES-CBC";
      length = 128;
    } else if (algorithm === "aes-256-cbc") {
      algo = "AES-CBC";
      length = 256;
    } else {
      throw new Error(`Unsupported cipher algorithm "${algorithm}"`);
    }
    const cryptoKey = await this.subtleCrypto.importKey("raw", key, { name: algo, length }, false, [
      "decrypt"
    ]);
    const result = await this.subtleCrypto.decrypt({ name: algo, iv }, cryptoKey, data);
    return new Uint8Array(result);
  }
};
async function createCipher() {
  const cryptoLib = await getCryptoLib();
  if (cryptoLib.name === "subtleCrypto") {
    return new WebCryptoAesCipher(cryptoLib.lib);
  }
  return new NodeCryptoAesCipher(cryptoLib.lib.createCipheriv, cryptoLib.lib.createDecipheriv);
}

// node_modules/@stacks/encryption/dist/esm/keys.js
var import_bs58 = __toESM(require_bs58());

// node_modules/@stacks/encryption/dist/esm/hashRipemd160.js
function hashRipemd160(data) {
  return ripemd160(data);
}

// node_modules/@stacks/encryption/dist/esm/sha2Hash.js
function hashSha256Sync(data) {
  return sha256(data);
}
function hashSha512Sync(data) {
  return sha512(data);
}

// node_modules/@stacks/encryption/dist/esm/keys.js
var BITCOIN_PUBKEYHASH = 0;
utils.hmacSha256Sync = (key, ...msgs) => {
  const h = hmac.create(sha256, key);
  msgs.forEach((msg) => h.update(msg));
  return h.digest();
};
function makeECPrivateKey() {
  return bytesToHex(utils.randomPrivateKey());
}
function base58Encode(hash) {
  const checksum = sha256(sha256(hash));
  return import_bs58.default.encode(concatBytes(hash, checksum).slice(0, hash.length + 4));
}
function base58CheckEncode(version, hash) {
  return base58Encode(concatBytes(new Uint8Array([version]), hash.slice(0, 20)));
}
function publicKeyToBtcAddress(publicKey, version = BITCOIN_PUBKEYHASH) {
  const publicKeyBytes = typeof publicKey === "string" ? hexToBytes(publicKey) : publicKey;
  const publicKeyHash160 = hashRipemd160(hashSha256Sync(publicKeyBytes));
  return base58CheckEncode(version, publicKeyHash160);
}
function getPublicKeyFromPrivate(privateKey) {
  const privateKeyBytes = privateKeyToBytes(privateKey);
  return bytesToHex(getPublicKey(privateKeyBytes.slice(0, 32), true));
}
function isValidPrivateKey(privateKey) {
  return utils.isValidPrivateKey(privateKeyToBytes(privateKey));
}

// node_modules/@stacks/encryption/dist/esm/ec.js
utils.hmacSha256Sync = (key, ...msgs) => {
  const h = hmac.create(sha256, key);
  msgs.forEach((msg) => h.update(msg));
  return h.digest();
};
var InvalidPublicKeyReason;
(function(InvalidPublicKeyReason2) {
  InvalidPublicKeyReason2["InvalidFormat"] = "InvalidFormat";
  InvalidPublicKeyReason2["IsNotPoint"] = "IsNotPoint";
})(InvalidPublicKeyReason || (InvalidPublicKeyReason = {}));
async function aes256CbcEncrypt(iv, key, plaintext) {
  const cipher = await createCipher();
  return await cipher.encrypt("aes-256-cbc", key, iv, plaintext);
}
async function aes256CbcDecrypt(iv, key, ciphertext) {
  const cipher = await createCipher();
  return await cipher.decrypt("aes-256-cbc", key, iv, ciphertext);
}
function hmacSha256(key, content) {
  return hmac(sha256, key, content);
}
function equalsConstTime(a2, b2) {
  if (a2.length !== b2.length) {
    return false;
  }
  let res = 0;
  for (let i = 0; i < a2.length; i++) {
    res |= a2[i] ^ b2[i];
  }
  return res === 0;
}
function sharedSecretToKeys(sharedSecret) {
  const hashedSecret = hashSha512Sync(sharedSecret);
  return {
    encryptionKey: hashedSecret.slice(0, 32),
    hmacKey: hashedSecret.slice(32)
  };
}
function allHexChars(maybe) {
  return maybe.match(/^[0-9a-f]+$/i) !== null;
}
function isValidPublicKey(pub) {
  const invalidFormat = {
    result: false,
    reason_data: "Invalid public key format",
    reason: InvalidPublicKeyReason.InvalidFormat
  };
  const invalidPoint = {
    result: false,
    reason_data: "Public key is not a point",
    reason: InvalidPublicKeyReason.IsNotPoint
  };
  if (pub.length !== 66 && pub.length !== 130)
    return invalidFormat;
  const firstByte = pub.slice(0, 2);
  if (pub.length === 130 && firstByte !== "04")
    return invalidFormat;
  if (pub.length === 66 && firstByte !== "02" && firstByte !== "03")
    return invalidFormat;
  if (!allHexChars(pub))
    return invalidFormat;
  try {
    const point = Point.fromHex(pub);
    point.assertValidity();
    return {
      result: true,
      reason_data: null,
      reason: null
    };
  } catch (e) {
    return invalidPoint;
  }
}
async function encryptECIES(publicKey, content, wasString, cipherTextEncoding) {
  const validity = isValidPublicKey(publicKey);
  if (!validity.result) {
    throw validity;
  }
  const ephemeralPrivateKey = utils.randomPrivateKey();
  const ephemeralPublicKey = getPublicKey(ephemeralPrivateKey, true);
  let sharedSecret = getSharedSecret(ephemeralPrivateKey, publicKey, true);
  sharedSecret = sharedSecret.slice(1);
  const sharedKeys = sharedSecretToKeys(sharedSecret);
  const initializationVector = utils.randomBytes(16);
  const cipherText = await aes256CbcEncrypt(initializationVector, sharedKeys.encryptionKey, content);
  const macData = concatBytes(initializationVector, ephemeralPublicKey, cipherText);
  const mac = hmacSha256(sharedKeys.hmacKey, macData);
  let cipherTextString;
  if (!cipherTextEncoding || cipherTextEncoding === "hex") {
    cipherTextString = bytesToHex(cipherText);
  } else if (cipherTextEncoding === "base64") {
    cipherTextString = (0, import_base64_js.fromByteArray)(cipherText);
  } else {
    throw new Error(`Unexpected cipherTextEncoding "${cipherTextEncoding}"`);
  }
  const result = {
    iv: bytesToHex(initializationVector),
    ephemeralPK: bytesToHex(ephemeralPublicKey),
    cipherText: cipherTextString,
    mac: bytesToHex(mac),
    wasString
  };
  if (cipherTextEncoding && cipherTextEncoding !== "hex") {
    result.cipherTextEncoding = cipherTextEncoding;
  }
  return result;
}
async function decryptECIES(privateKey, cipherObject) {
  if (!cipherObject.ephemeralPK) {
    throw new FailedDecryptionError("Unable to get public key from cipher object. You might be trying to decrypt an unencrypted object.");
  }
  const ephemeralPK = cipherObject.ephemeralPK;
  let sharedSecret = getSharedSecret(privateKey, ephemeralPK, true);
  sharedSecret = sharedSecret.slice(1);
  const sharedKeys = sharedSecretToKeys(sharedSecret);
  const ivBytes = hexToBytes(cipherObject.iv);
  let cipherTextBytes;
  if (!cipherObject.cipherTextEncoding || cipherObject.cipherTextEncoding === "hex") {
    cipherTextBytes = hexToBytes(cipherObject.cipherText);
  } else if (cipherObject.cipherTextEncoding === "base64") {
    cipherTextBytes = (0, import_base64_js.toByteArray)(cipherObject.cipherText);
  } else {
    throw new Error(`Unexpected cipherTextEncoding "${cipherObject.cipherText}"`);
  }
  const macData = concatBytes(ivBytes, hexToBytes(ephemeralPK), cipherTextBytes);
  const actualMac = hmacSha256(sharedKeys.hmacKey, macData);
  const expectedMac = hexToBytes(cipherObject.mac);
  if (!equalsConstTime(expectedMac, actualMac)) {
    throw new FailedDecryptionError("Decryption failed: failure in MAC check");
  }
  const plainText = await aes256CbcDecrypt(ivBytes, sharedKeys.encryptionKey, cipherTextBytes);
  if (cipherObject.wasString) {
    return bytesToUtf8(plainText);
  }
  return plainText;
}
function signECDSA(privateKey, content) {
  const contentBytes = typeof content === "string" ? utf8ToBytes(content) : content;
  const publicKey = getPublicKeyFromPrivate(privateKey);
  const contentHash = hashSha256Sync(contentBytes);
  const signature = signSync(contentHash, privateKey);
  return {
    signature: bytesToHex(signature),
    publicKey
  };
}

// node_modules/@stacks/encryption/dist/esm/encryption.js
async function encryptContent(content, options) {
  const opts = Object.assign({}, options);
  let privateKey;
  if (!opts.publicKey) {
    if (!opts.privateKey) {
      throw new Error("Either public key or private key must be supplied for encryption.");
    }
    opts.publicKey = getPublicKeyFromPrivate(opts.privateKey);
  }
  const wasString = typeof opts.wasString === "boolean" ? opts.wasString : typeof content === "string";
  const contentBytes = typeof content === "string" ? utf8ToBytes(content) : content;
  const cipherObject = await encryptECIES(opts.publicKey, contentBytes, wasString, opts.cipherTextEncoding);
  let cipherPayload = JSON.stringify(cipherObject);
  if (opts.sign) {
    if (typeof opts.sign === "string") {
      privateKey = opts.sign;
    } else if (!privateKey) {
      privateKey = opts.privateKey;
    }
    const signatureObject = signECDSA(privateKey, cipherPayload);
    const signedCipherObject = {
      signature: signatureObject.signature,
      publicKey: signatureObject.publicKey,
      cipherText: cipherPayload
    };
    cipherPayload = JSON.stringify(signedCipherObject);
  }
  return cipherPayload;
}
function decryptContent(content, options) {
  const opts = Object.assign({}, options);
  if (!opts.privateKey) {
    throw new Error("Private key is required for decryption.");
  }
  try {
    const cipherObject = JSON.parse(content);
    return decryptECIES(opts.privateKey, cipherObject);
  } catch (err) {
    if (err instanceof SyntaxError) {
      throw new Error("Failed to parse encrypted content JSON. The content may not be encrypted. If using getFile, try passing { decrypt: false }.");
    } else {
      throw err;
    }
  }
}

// node_modules/@stacks/encryption/dist/esm/wallet.js
var import_bip39 = __toESM(require_bip39());
var import_english = __toESM(require_english());

// node_modules/@stacks/auth/dist/esm/messages.js
var import_jsontokens = __toESM(require_lib3());

// node_modules/@stacks/auth/dist/esm/dids.js
function makeDIDFromAddress(address) {
  return `did:btc-addr:${address}`;
}
function makeDIDFromPublicKey(publicKey) {
  return `did:ecdsa-pub:${publicKey}`;
}
function getDIDType(decentralizedID) {
  const didParts = decentralizedID.split(":");
  if (didParts.length !== 3) {
    throw new InvalidDIDError("Decentralized IDs must have 3 parts");
  }
  if (didParts[0].toLowerCase() !== "did") {
    throw new InvalidDIDError('Decentralized IDs must start with "did"');
  }
  return didParts[1].toLowerCase();
}
function getAddressFromDID(decentralizedID) {
  if (decentralizedID) {
    const didType = getDIDType(decentralizedID);
    if (didType === "btc-addr") {
      return decentralizedID.split(":")[2];
    } else {
      return void 0;
    }
  }
  return void 0;
}

// node_modules/@stacks/auth/dist/esm/messages.js
var VERSION = "1.4.0";
function generateTransitKey() {
  const transitKey = makeECPrivateKey();
  return transitKey;
}
var makeAuthRequest = makeAuthRequestToken;
function makeAuthRequestToken(transitPrivateKey, redirectURI, manifestURI, scopes = DEFAULT_SCOPE.slice(), appDomain, expiresAt = nextMonth().getTime(), extraParams = {}) {
  const getWindowOrigin = (paramName) => {
    const location2 = getGlobalObject("location", {
      throwIfUnavailable: true,
      usageDesc: `makeAuthRequest([${paramName}=undefined])`
    });
    return location2 == null ? void 0 : location2.origin;
  };
  if (!redirectURI) {
    redirectURI = `${getWindowOrigin("redirectURI")}/`;
  }
  if (!manifestURI) {
    manifestURI = `${getWindowOrigin("manifestURI")}/manifest.json`;
  }
  if (!appDomain) {
    appDomain = getWindowOrigin("appDomain");
  }
  const payload = Object.assign({}, extraParams, {
    jti: makeUUID4(),
    iat: Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3),
    exp: Math.floor(expiresAt / 1e3),
    iss: null,
    public_keys: [],
    domain_name: appDomain,
    manifest_uri: manifestURI,
    redirect_uri: redirectURI,
    version: VERSION,
    do_not_include_profile: true,
    supports_hub_url: true,
    scopes
  });
  const publicKey = import_jsontokens.SECP256K1Client.derivePublicKey(transitPrivateKey);
  payload.public_keys = [publicKey];
  const address = publicKeyToBtcAddress(publicKey);
  payload.iss = makeDIDFromAddress(address);
  const tokenSigner = new import_jsontokens.TokenSigner("ES256k", transitPrivateKey);
  const token = tokenSigner.sign(payload);
  return token;
}
async function encryptPrivateKey(publicKey, privateKey) {
  const encryptedObj = await encryptECIES(publicKey, utf8ToBytes(privateKey), true);
  const encryptedJSON = JSON.stringify(encryptedObj);
  return bytesToHex(utf8ToBytes(encryptedJSON));
}
async function decryptPrivateKey(privateKey, hexedEncrypted) {
  const unhexedString = bytesToUtf8(hexToBytes(hexedEncrypted));
  const encryptedObj = JSON.parse(unhexedString);
  const decrypted = await decryptECIES(privateKey, encryptedObj);
  if (typeof decrypted !== "string") {
    throw new Error("Unable to correctly decrypt private key");
  } else {
    return decrypted;
  }
}
async function makeAuthResponse(privateKey, profile = {}, metadata, coreToken = null, appPrivateKey = null, expiresAt = nextMonth().getTime(), transitPublicKey = null, hubUrl = null, blockstackAPIUrl = null, associationToken = null, appPrivateKeyFromWalletSalt = null) {
  const publicKey = import_jsontokens.SECP256K1Client.derivePublicKey(privateKey);
  const address = publicKeyToBtcAddress(publicKey);
  let privateKeyPayload = appPrivateKey;
  let coreTokenPayload = coreToken;
  let additionalProperties = {};
  if (appPrivateKey !== void 0 && appPrivateKey !== null) {
    if (transitPublicKey !== void 0 && transitPublicKey !== null) {
      privateKeyPayload = await encryptPrivateKey(transitPublicKey, appPrivateKey);
      if (coreToken !== void 0 && coreToken !== null) {
        coreTokenPayload = await encryptPrivateKey(transitPublicKey, coreToken);
      }
    }
    additionalProperties = {
      email: (metadata == null ? void 0 : metadata.email) ? metadata.email : null,
      profile_url: (metadata == null ? void 0 : metadata.profileUrl) ? metadata.profileUrl : null,
      hubUrl,
      blockstackAPIUrl,
      associationToken,
      version: VERSION
    };
  } else {
  }
  const payload = Object.assign({}, {
    jti: makeUUID4(),
    iat: Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3),
    exp: Math.floor(expiresAt / 1e3),
    iss: makeDIDFromAddress(address),
    private_key: privateKeyPayload,
    public_keys: [publicKey],
    appPrivateKeyFromWalletSalt,
    profile,
    core_token: coreTokenPayload
  }, additionalProperties);
  const tokenSigner = new import_jsontokens.TokenSigner("ES256k", privateKey);
  return tokenSigner.sign(payload);
}

// node_modules/@stacks/auth/dist/esm/provider.js
var import_jsontokens2 = __toESM(require_lib3());
function getAuthRequestFromURL() {
  var _a;
  const location2 = getGlobalObject("location", {
    throwIfUnavailable: true,
    usageDesc: "getAuthRequestFromURL"
  });
  const params = new URLSearchParams(location2 == null ? void 0 : location2.search);
  return ((_a = params.get("authRequest")) == null ? void 0 : _a.replaceAll(`${BLOCKSTACK_HANDLER}:`, "")) ?? null;
}
async function fetchAppManifest(authRequest, fetchFn = createFetchFn()) {
  if (!authRequest) {
    throw new Error("Invalid auth request");
  }
  const payload = (0, import_jsontokens2.decodeToken)(authRequest).payload;
  if (typeof payload === "string") {
    throw new Error("Unexpected token payload type of string");
  }
  const manifestURI = payload.manifest_uri;
  try {
    const response = await fetchFn(manifestURI);
    const responseText = await response.text();
    const responseJSON = JSON.parse(responseText);
    return { ...responseJSON, manifestURI };
  } catch (error) {
    console.log(error);
    throw new Error("Could not fetch manifest.json");
  }
}

// node_modules/@stacks/auth/dist/esm/verification.js
var import_jsontokens3 = __toESM(require_lib3());
function doSignaturesMatchPublicKeys(token) {
  const payload = (0, import_jsontokens3.decodeToken)(token).payload;
  if (typeof payload === "string") {
    throw new Error("Unexpected token payload type of string");
  }
  const publicKeys = payload.public_keys;
  if (publicKeys.length === 1) {
    const publicKey = publicKeys[0];
    try {
      const tokenVerifier = new import_jsontokens3.TokenVerifier("ES256k", publicKey);
      return tokenVerifier.verify(token);
    } catch (e) {
      return false;
    }
  } else {
    throw new Error("Multiple public keys are not supported");
  }
}
function doPublicKeysMatchIssuer(token) {
  const payload = (0, import_jsontokens3.decodeToken)(token).payload;
  if (typeof payload === "string") {
    throw new Error("Unexpected token payload type of string");
  }
  const publicKeys = payload.public_keys;
  const addressFromIssuer = getAddressFromDID(payload.iss);
  if (publicKeys.length === 1) {
    const addressFromPublicKeys = publicKeyToBtcAddress(publicKeys[0]);
    if (addressFromPublicKeys === addressFromIssuer) {
      return true;
    }
  } else {
    throw new Error("Multiple public keys are not supported");
  }
  return false;
}
function isIssuanceDateValid(token) {
  const payload = (0, import_jsontokens3.decodeToken)(token).payload;
  if (typeof payload === "string") {
    throw new Error("Unexpected token payload type of string");
  }
  if (payload.iat) {
    if (typeof payload.iat !== "number") {
      return false;
    }
    const issuedAt = new Date(payload.iat * 1e3);
    if ((/* @__PURE__ */ new Date()).getTime() < issuedAt.getTime()) {
      return false;
    } else {
      return true;
    }
  } else {
    return true;
  }
}
function isExpirationDateValid(token) {
  const payload = (0, import_jsontokens3.decodeToken)(token).payload;
  if (typeof payload === "string") {
    throw new Error("Unexpected token payload type of string");
  }
  if (payload.exp) {
    if (typeof payload.exp !== "number") {
      return false;
    }
    const expiresAt = new Date(payload.exp * 1e3);
    if ((/* @__PURE__ */ new Date()).getTime() > expiresAt.getTime()) {
      return false;
    } else {
      return true;
    }
  } else {
    return true;
  }
}
function isManifestUriValid(token) {
  const payload = (0, import_jsontokens3.decodeToken)(token).payload;
  if (typeof payload === "string") {
    throw new Error("Unexpected token payload type of string");
  }
  return isSameOriginAbsoluteUrl(payload.domain_name, payload.manifest_uri);
}
function isRedirectUriValid(token) {
  const payload = (0, import_jsontokens3.decodeToken)(token).payload;
  if (typeof payload === "string") {
    throw new Error("Unexpected token payload type of string");
  }
  return isSameOriginAbsoluteUrl(payload.domain_name, payload.redirect_uri);
}
async function verifyAuthRequest(token) {
  if ((0, import_jsontokens3.decodeToken)(token).header.alg === "none") {
    throw new Error("Token must be signed in order to be verified");
  }
  const values = await Promise.all([
    isExpirationDateValid(token),
    isIssuanceDateValid(token),
    doSignaturesMatchPublicKeys(token),
    doPublicKeysMatchIssuer(token),
    isManifestUriValid(token),
    isRedirectUriValid(token)
  ]);
  return values.every((val) => val);
}
async function verifyAuthRequestAndLoadManifest(token) {
  const valid = await verifyAuthRequest(token);
  if (!valid) {
    throw new Error("Token is an invalid auth request");
  }
  return fetchAppManifest(token);
}
async function verifyAuthResponse(token) {
  const conditions = await Promise.all([
    isExpirationDateValid(token),
    isIssuanceDateValid(token),
    doSignaturesMatchPublicKeys(token),
    doPublicKeysMatchIssuer(token)
  ]);
  return conditions.every((val) => val);
}

// node_modules/@stacks/auth/dist/esm/sessionData.js
var SESSION_VERSION = "1.0.0";
var SessionData = class _SessionData {
  constructor(options) {
    this.version = SESSION_VERSION;
    this.userData = options.userData;
    this.transitKey = options.transitKey;
    this.etags = options.etags ? options.etags : {};
  }
  static fromJSON(json) {
    if (json.version !== SESSION_VERSION) {
      throw new InvalidStateError(`JSON data version ${json.version} not supported by SessionData`);
    }
    const options = {
      coreNode: json.coreNode,
      userData: json.userData,
      transitKey: json.transitKey,
      etags: json.etags
    };
    return new _SessionData(options);
  }
  toString() {
    return JSON.stringify(this);
  }
};

// node_modules/@stacks/auth/dist/esm/sessionStore.js
var SessionDataStore = class {
  constructor(sessionOptions) {
    if (sessionOptions) {
      const newSessionData = new SessionData(sessionOptions);
      this.setSessionData(newSessionData);
    }
  }
  getSessionData() {
    throw new Error("Abstract class");
  }
  setSessionData(_session) {
    throw new Error("Abstract class");
  }
  deleteSessionData() {
    throw new Error("Abstract class");
  }
};
var InstanceDataStore = class extends SessionDataStore {
  constructor(sessionOptions) {
    super(sessionOptions);
    if (!this.sessionData) {
      this.setSessionData(new SessionData({}));
    }
  }
  getSessionData() {
    if (!this.sessionData) {
      throw new NoSessionDataError("No session data was found.");
    }
    return this.sessionData;
  }
  setSessionData(session) {
    this.sessionData = session;
    return true;
  }
  deleteSessionData() {
    this.setSessionData(new SessionData({}));
    return true;
  }
};
var LocalStorageStore = class extends SessionDataStore {
  constructor(sessionOptions) {
    super(sessionOptions);
    if (sessionOptions && sessionOptions.storeOptions && sessionOptions.storeOptions.localStorageKey && typeof sessionOptions.storeOptions.localStorageKey === "string") {
      this.key = sessionOptions.storeOptions.localStorageKey;
    } else {
      this.key = LOCALSTORAGE_SESSION_KEY;
    }
    const data = localStorage.getItem(this.key);
    if (!data) {
      const sessionData = new SessionData({});
      this.setSessionData(sessionData);
    }
  }
  getSessionData() {
    const data = localStorage.getItem(this.key);
    if (!data) {
      throw new NoSessionDataError("No session data was found in localStorage");
    }
    const dataJSON = JSON.parse(data);
    return SessionData.fromJSON(dataJSON);
  }
  setSessionData(session) {
    localStorage.setItem(this.key, session.toString());
    return true;
  }
  deleteSessionData() {
    localStorage.removeItem(this.key);
    this.setSessionData(new SessionData({}));
    return true;
  }
};

// node_modules/@stacks/auth/dist/esm/userSession.js
var import_jsontokens5 = __toESM(require_lib3());

// node_modules/@stacks/profile/dist/esm/profileTokens.js
var import_jsontokens4 = __toESM(require_lib3());
function signProfileToken(profile, privateKey, subject, issuer, signingAlgorithm = "ES256K", issuedAt = /* @__PURE__ */ new Date(), expiresAt = nextYear()) {
  if (signingAlgorithm !== "ES256K") {
    throw new Error("Signing algorithm not supported");
  }
  const publicKey = import_jsontokens4.SECP256K1Client.derivePublicKey(privateKey);
  if (!subject) {
    subject = { publicKey };
  }
  if (!issuer) {
    issuer = { publicKey };
  }
  const tokenSigner = new import_jsontokens4.TokenSigner(signingAlgorithm, privateKey);
  const payload = {
    jti: makeUUID4(),
    iat: issuedAt.toISOString(),
    exp: expiresAt.toISOString(),
    subject,
    issuer,
    claim: profile
  };
  return tokenSigner.sign(payload);
}
function verifyProfileToken(token, publicKeyOrAddress) {
  const decodedToken = (0, import_jsontokens4.decodeToken)(token);
  const payload = decodedToken.payload;
  if (typeof payload === "string") {
    throw new Error("Unexpected token payload type of string");
  }
  if (payload.hasOwnProperty("subject") && payload.subject) {
    if (!payload.subject.hasOwnProperty("publicKey")) {
      throw new Error("Token doesn't have a subject public key");
    }
  } else {
    throw new Error("Token doesn't have a subject");
  }
  if (payload.hasOwnProperty("issuer") && payload.issuer) {
    if (!payload.issuer.hasOwnProperty("publicKey")) {
      throw new Error("Token doesn't have an issuer public key");
    }
  } else {
    throw new Error("Token doesn't have an issuer");
  }
  if (!payload.hasOwnProperty("claim")) {
    throw new Error("Token doesn't have a claim");
  }
  const issuerPublicKey = payload.issuer.publicKey;
  const address = getAddressFromPublicKey(issuerPublicKey);
  if (publicKeyOrAddress === issuerPublicKey) {
  } else if (publicKeyOrAddress === address) {
  } else {
    throw new Error("Token issuer public key does not match the verifying value");
  }
  const tokenVerifier = new import_jsontokens4.TokenVerifier(decodedToken.header.alg, issuerPublicKey);
  if (!tokenVerifier) {
    throw new Error("Invalid token verifier");
  }
  const tokenVerified = tokenVerifier.verify(token);
  if (!tokenVerified) {
    throw new Error("Token verification failed");
  }
  return decodedToken;
}
function extractProfile(token, publicKeyOrAddress = null) {
  let decodedToken;
  if (publicKeyOrAddress) {
    decodedToken = verifyProfileToken(token, publicKeyOrAddress);
  } else {
    decodedToken = (0, import_jsontokens4.decodeToken)(token);
  }
  let profile = {};
  if (decodedToken.hasOwnProperty("payload")) {
    const payload = decodedToken.payload;
    if (typeof payload === "string") {
      throw new Error("Unexpected token payload type of string");
    }
    if (payload.hasOwnProperty("claim")) {
      profile = payload.claim;
    }
  }
  return profile;
}

// node_modules/@stacks/profile/dist/esm/profileSchemas/personLegacy.js
function formatAccount(serviceName, data) {
  let proofUrl;
  if (data.proof && data.proof.url) {
    proofUrl = data.proof.url;
  }
  return {
    "@type": "Account",
    service: serviceName,
    identifier: data.username,
    proofType: "http",
    proofUrl
  };
}
function getPersonFromLegacyFormat(profile) {
  const profileData = {
    "@type": "Person"
  };
  if (profile) {
    if (profile.name && profile.name.formatted) {
      profileData.name = profile.name.formatted;
    }
    if (profile.bio) {
      profileData.description = profile.bio;
    }
    if (profile.location && profile.location.formatted) {
      profileData.address = {
        "@type": "PostalAddress",
        addressLocality: profile.location.formatted
      };
    }
    const images = [];
    if (profile.avatar && profile.avatar.url) {
      images.push({
        "@type": "ImageObject",
        name: "avatar",
        contentUrl: profile.avatar.url
      });
    }
    if (profile.cover && profile.cover.url) {
      images.push({
        "@type": "ImageObject",
        name: "cover",
        contentUrl: profile.cover.url
      });
    }
    if (images.length) {
      profileData.image = images;
    }
    if (profile.website) {
      profileData.website = [
        {
          "@type": "WebSite",
          url: profile.website
        }
      ];
    }
    const accounts = [];
    if (profile.bitcoin && profile.bitcoin.address) {
      accounts.push({
        "@type": "Account",
        role: "payment",
        service: "bitcoin",
        identifier: profile.bitcoin.address
      });
    }
    if (profile.twitter && profile.twitter.username) {
      accounts.push(formatAccount("twitter", profile.twitter));
    }
    if (profile.facebook && profile.facebook.username) {
      accounts.push(formatAccount("facebook", profile.facebook));
    }
    if (profile.github && profile.github.username) {
      accounts.push(formatAccount("github", profile.github));
    }
    if (profile.auth) {
      if (profile.auth.length > 0) {
        if (profile.auth[0] && profile.auth[0].publicKeychain) {
          accounts.push({
            "@type": "Account",
            role: "key",
            service: "bip32",
            identifier: profile.auth[0].publicKeychain
          });
        }
      }
    }
    if (profile.pgp && profile.pgp.url) {
      accounts.push({
        "@type": "Account",
        role: "key",
        service: "pgp",
        identifier: profile.pgp.fingerprint,
        contentUrl: profile.pgp.url
      });
    }
    profileData.account = accounts;
  }
  return profileData;
}

// node_modules/@stacks/profile/dist/esm/profileSchemas/personZoneFiles.js
var import_zone_file = __toESM(require_dist());

// node_modules/@stacks/profile/dist/esm/profileSchemas/personUtils.js
function getName(profile) {
  if (!profile) {
    return null;
  }
  let name = null;
  if (profile.name) {
    name = profile.name;
  } else if (profile.givenName || profile.familyName) {
    name = "";
    if (profile.givenName) {
      name = profile.givenName;
    }
    if (profile.familyName) {
      name += ` ${profile.familyName}`;
    }
  }
  return name;
}
function getGivenName(profile) {
  if (!profile) {
    return null;
  }
  let givenName = null;
  if (profile.givenName) {
    givenName = profile.givenName;
  } else if (profile.name) {
    const nameParts = profile.name.split(" ");
    givenName = nameParts.slice(0, -1).join(" ");
  }
  return givenName;
}
function getFamilyName(profile) {
  if (!profile) {
    return null;
  }
  let familyName = null;
  if (profile.familyName) {
    familyName = profile.familyName;
  } else if (profile.name) {
    const nameParts = profile.name.split(" ");
    familyName = nameParts.pop();
  }
  return familyName;
}
function getDescription(profile) {
  if (!profile) {
    return null;
  }
  let description = null;
  if (profile.description) {
    description = profile.description;
  }
  return description;
}
function getAvatarUrl(profile) {
  if (!profile) {
    return null;
  }
  let avatarContentUrl = null;
  if (profile.image) {
    profile.image.map((image) => {
      if (image.name === "avatar") {
        avatarContentUrl = image.contentUrl;
        return avatarContentUrl;
      } else {
        return null;
      }
    });
  }
  return avatarContentUrl;
}
function getVerifiedAccounts(profile, verifications) {
  if (!profile) {
    return null;
  }
  const filteredAccounts = [];
  if (profile.hasOwnProperty("account") && verifications) {
    profile.account.map((account) => {
      let accountIsValid = false;
      let proofUrl = null;
      verifications.map((verification) => {
        if (verification.hasOwnProperty("proof_url")) {
          verification.proofUrl = verification.proof_url;
        }
        if (verification.valid && verification.service === account.service && verification.identifier === account.identifier && verification.proofUrl) {
          accountIsValid = true;
          proofUrl = verification.proofUrl;
          return true;
        } else {
          return false;
        }
      });
      if (accountIsValid) {
        account.proofUrl = proofUrl;
        filteredAccounts.push(account);
        return account;
      } else {
        return null;
      }
    });
  }
  return filteredAccounts;
}
function getOrganizations(profile) {
  if (!profile) {
    return null;
  }
  const organizations = [];
  if (profile.hasOwnProperty("worksFor")) {
    return profile.worksFor;
  }
  return organizations;
}
function getConnections(profile) {
  if (!profile) {
    return null;
  }
  let connections = [];
  if (profile.hasOwnProperty("knows")) {
    connections = profile.knows;
  }
  return connections;
}
function getAddress(profile) {
  if (!profile) {
    return null;
  }
  let addressString = null;
  if (profile.hasOwnProperty("address")) {
    const addressParts = [];
    if (profile.address.hasOwnProperty("streetAddress")) {
      addressParts.push(profile.address.streetAddress);
    }
    if (profile.address.hasOwnProperty("addressLocality")) {
      addressParts.push(profile.address.addressLocality);
    }
    if (profile.address.hasOwnProperty("postalCode")) {
      addressParts.push(profile.address.postalCode);
    }
    if (profile.address.hasOwnProperty("addressCountry")) {
      addressParts.push(profile.address.addressCountry);
    }
    if (addressParts.length) {
      addressString = addressParts.join(", ");
    }
  }
  return addressString;
}
function getBirthDate(profile) {
  if (!profile) {
    return null;
  }
  const monthNames = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ];
  let birthDateString = null;
  if (profile.hasOwnProperty("birthDate")) {
    const date = new Date(profile.birthDate);
    birthDateString = `${monthNames[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;
  }
  return birthDateString;
}

// node_modules/@stacks/profile/dist/esm/profile.js
var import_zone_file2 = __toESM(require_dist());
var inspector = __toESM(require_schema_inspector2());
var schemaDefinition = {
  type: "object",
  properties: {
    "@context": { type: "string", optional: true },
    "@type": { type: "string" }
  }
};
var Profile = class _Profile {
  constructor(profile = {}) {
    this._profile = Object.assign({}, {
      "@context": "http://schema.org/"
    }, profile);
  }
  toJSON() {
    return Object.assign({}, this._profile);
  }
  toToken(privateKey) {
    return signProfileToken(this.toJSON(), privateKey);
  }
  static validateSchema(profile, strict = false) {
    schemaDefinition.strict = strict;
    return inspector.validate(schemaDefinition, profile);
  }
  static fromToken(token, publicKeyOrAddress = null) {
    const profile = extractProfile(token, publicKeyOrAddress);
    return new _Profile(profile);
  }
  static makeZoneFile(domainName, tokenFileURL) {
    return makeProfileZoneFile(domainName, tokenFileURL);
  }
};
var personSchemaDefinition = {
  type: "object",
  strict: false,
  properties: {
    "@context": { type: "string", optional: true },
    "@type": { type: "string" },
    "@id": { type: "string", optional: true },
    name: { type: "string", optional: true },
    givenName: { type: "string", optional: true },
    familyName: { type: "string", optional: true },
    description: { type: "string", optional: true },
    image: {
      type: "array",
      optional: true,
      items: {
        type: "object",
        properties: {
          "@type": { type: "string" },
          name: { type: "string", optional: true },
          contentUrl: { type: "string", optional: true }
        }
      }
    },
    website: {
      type: "array",
      optional: true,
      items: {
        type: "object",
        properties: {
          "@type": { type: "string" },
          url: { type: "string", optional: true }
        }
      }
    },
    account: {
      type: "array",
      optional: true,
      items: {
        type: "object",
        properties: {
          "@type": { type: "string" },
          service: { type: "string", optional: true },
          identifier: { type: "string", optional: true },
          proofType: { type: "string", optional: true },
          proofUrl: { type: "string", optional: true },
          proofMessage: { type: "string", optional: true },
          proofSignature: { type: "string", optional: true }
        }
      }
    },
    worksFor: {
      type: "array",
      optional: true,
      items: {
        type: "object",
        properties: {
          "@type": { type: "string" },
          "@id": { type: "string", optional: true }
        }
      }
    },
    knows: {
      type: "array",
      optional: true,
      items: {
        type: "object",
        properties: {
          "@type": { type: "string" },
          "@id": { type: "string", optional: true }
        }
      }
    },
    address: {
      type: "object",
      optional: true,
      properties: {
        "@type": { type: "string" },
        streetAddress: { type: "string", optional: true },
        addressLocality: { type: "string", optional: true },
        postalCode: { type: "string", optional: true },
        addressCountry: { type: "string", optional: true }
      }
    },
    birthDate: { type: "string", optional: true },
    taxID: { type: "string", optional: true }
  }
};
var Person = class _Person extends Profile {
  constructor(profile = { "@type": "Person" }) {
    super(profile);
    this._profile = Object.assign({}, {
      "@type": "Person"
    }, this._profile);
  }
  static validateSchema(profile, strict = false) {
    personSchemaDefinition.strict = strict;
    return inspector.validate(schemaDefinition, profile);
  }
  static fromToken(token, publicKeyOrAddress = null) {
    const profile = extractProfile(token, publicKeyOrAddress);
    return new _Person(profile);
  }
  static fromLegacyFormat(legacyProfile) {
    const profile = getPersonFromLegacyFormat(legacyProfile);
    return new _Person(profile);
  }
  toJSON() {
    return {
      profile: this.profile(),
      name: this.name(),
      givenName: this.givenName(),
      familyName: this.familyName(),
      description: this.description(),
      avatarUrl: this.avatarUrl(),
      verifiedAccounts: this.verifiedAccounts(),
      address: this.address(),
      birthDate: this.birthDate(),
      connections: this.connections(),
      organizations: this.organizations()
    };
  }
  profile() {
    return Object.assign({}, this._profile);
  }
  name() {
    return getName(this.profile());
  }
  givenName() {
    return getGivenName(this.profile());
  }
  familyName() {
    return getFamilyName(this.profile());
  }
  description() {
    return getDescription(this.profile());
  }
  avatarUrl() {
    return getAvatarUrl(this.profile());
  }
  verifiedAccounts(verifications) {
    return getVerifiedAccounts(this.profile(), verifications);
  }
  address() {
    return getAddress(this.profile());
  }
  birthDate() {
    return getBirthDate(this.profile());
  }
  connections() {
    return getConnections(this.profile());
  }
  organizations() {
    return getOrganizations(this.profile());
  }
};
function makeProfileZoneFile(origin, tokenFileUrl) {
  if (!tokenFileUrl.includes("://")) {
    throw new Error("Invalid token file url");
  }
  const urlScheme = tokenFileUrl.split("://")[0];
  const urlParts = tokenFileUrl.split("://")[1].split("/");
  const domain = urlParts[0];
  const pathname = `/${urlParts.slice(1).join("/")}`;
  const zoneFile = {
    $origin: origin,
    $ttl: 3600,
    uri: [
      {
        name: "_http._tcp",
        priority: 10,
        weight: 1,
        target: `${urlScheme}://${domain}${pathname}`
      }
    ]
  };
  const zoneFileTemplate = "{$origin}\n{$ttl}\n{uri}\n";
  return (0, import_zone_file2.makeZoneFile)(zoneFile, zoneFileTemplate);
}
function getTokenFileUrl(zoneFileJson) {
  if (!zoneFileJson.hasOwnProperty("uri")) {
    return null;
  }
  if (!Array.isArray(zoneFileJson.uri)) {
    return null;
  }
  if (zoneFileJson.uri.length < 1) {
    return null;
  }
  const validRecords = zoneFileJson.uri.filter((record) => record.hasOwnProperty("target") && record.name === "_http._tcp");
  if (validRecords.length < 1) {
    return null;
  }
  const firstValidRecord = validRecords[0];
  if (!firstValidRecord.hasOwnProperty("target")) {
    return null;
  }
  let tokenFileUrl = firstValidRecord.target;
  if (tokenFileUrl.startsWith("https")) {
  } else if (tokenFileUrl.startsWith("http")) {
  } else {
    tokenFileUrl = `https://${tokenFileUrl}`;
  }
  return tokenFileUrl;
}
function resolveZoneFileToProfile(zoneFile, publicKeyOrAddress, fetchFn = createFetchFn()) {
  return new Promise((resolve, reject) => {
    let zoneFileJson = null;
    try {
      zoneFileJson = (0, import_zone_file2.parseZoneFile)(zoneFile);
      if (!zoneFileJson.hasOwnProperty("$origin")) {
        zoneFileJson = null;
      }
    } catch (e) {
      reject(e);
    }
    let tokenFileUrl = null;
    if (zoneFileJson && Object.keys(zoneFileJson).length > 0) {
      tokenFileUrl = getTokenFileUrl(zoneFileJson);
    } else {
      try {
        return resolve(Person.fromLegacyFormat(JSON.parse(zoneFile)).profile());
      } catch (error) {
        return reject(error);
      }
    }
    if (tokenFileUrl) {
      fetchFn(tokenFileUrl).then((response) => response.text()).then((responseText) => JSON.parse(responseText)).then((responseJson) => {
        const tokenRecords = responseJson;
        const profile = extractProfile(tokenRecords[0].token, publicKeyOrAddress);
        resolve(profile);
      }).catch((error) => {
        Logger.error(`resolveZoneFileToProfile: error fetching token file ${tokenFileUrl}: ${error}`);
        reject(error);
      });
    } else {
      Logger.debug("Token file url not found. Resolving to blank profile.");
      resolve({});
    }
  });
}

// node_modules/@stacks/auth/dist/esm/protocolEchoDetection.js
var GLOBAL_DETECTION_CACHE_KEY = "_blockstackDidCheckEchoReply";
var ECHO_REPLY_PARAM = "echoReply";
var AUTH_CONTINUATION_PARAM = "authContinuation";
function getQueryStringParams(query) {
  if (!query) {
    return {};
  }
  const trimmed = /^[?#]/.test(query) ? query.slice(1) : query;
  return trimmed.split("&").reduce((params, param) => {
    const [key, value] = param.split("=");
    params[key] = value ? decodeURIComponent(value.replace(/\+/g, " ")) : "";
    return params;
  }, {});
}
function protocolEchoReplyDetection() {
  let globalScope;
  if (typeof self !== "undefined") {
    globalScope = self;
  } else if (typeof window !== "undefined") {
    globalScope = window;
  } else {
    return false;
  }
  if (!globalScope.location || !globalScope.localStorage) {
    return false;
  }
  const existingDetection = globalScope[GLOBAL_DETECTION_CACHE_KEY];
  if (typeof existingDetection === "boolean") {
    return existingDetection;
  }
  const searchParams = getQueryStringParams(globalScope.location.search);
  const echoReplyParam = searchParams[ECHO_REPLY_PARAM];
  if (echoReplyParam) {
    globalScope[GLOBAL_DETECTION_CACHE_KEY] = true;
    const echoReplyKey = `echo-reply-${echoReplyParam}`;
    globalScope.localStorage.setItem(echoReplyKey, "success");
    globalScope.setTimeout(() => {
      const authContinuationParam = searchParams[AUTH_CONTINUATION_PARAM];
      globalScope.location.href = authContinuationParam;
    }, 10);
    return true;
  }
  return false;
}

// node_modules/@stacks/auth/dist/esm/userSession.js
var UserSession = class {
  constructor(options) {
    let runningInBrowser = true;
    if (typeof window === "undefined" && typeof self === "undefined") {
      runningInBrowser = false;
    }
    if (options && options.appConfig) {
      this.appConfig = options.appConfig;
    } else if (runningInBrowser) {
      this.appConfig = new AppConfig();
    } else {
      throw new MissingParameterError("You need to specify options.appConfig");
    }
    if (options && options.sessionStore) {
      this.store = options.sessionStore;
    } else if (runningInBrowser) {
      if (options) {
        this.store = new LocalStorageStore(options.sessionOptions);
      } else {
        this.store = new LocalStorageStore();
      }
    } else if (options) {
      this.store = new InstanceDataStore(options.sessionOptions);
    } else {
      this.store = new InstanceDataStore();
    }
  }
  makeAuthRequestToken(transitKey, redirectURI, manifestURI, scopes, appDomain, expiresAt = nextHour().getTime(), extraParams = {}) {
    const appConfig = this.appConfig;
    if (!appConfig) {
      throw new InvalidStateError("Missing AppConfig");
    }
    transitKey = transitKey || this.generateAndStoreTransitKey();
    redirectURI = redirectURI || appConfig.redirectURI();
    manifestURI = manifestURI || appConfig.manifestURI();
    scopes = scopes || appConfig.scopes;
    appDomain = appDomain || appConfig.appDomain;
    return makeAuthRequestToken(transitKey, redirectURI, manifestURI, scopes, appDomain, expiresAt, extraParams);
  }
  generateAndStoreTransitKey() {
    const sessionData = this.store.getSessionData();
    const transitKey = generateTransitKey();
    sessionData.transitKey = transitKey;
    this.store.setSessionData(sessionData);
    return transitKey;
  }
  getAuthResponseToken() {
    var _a;
    const search = (_a = getGlobalObject("location", {
      throwIfUnavailable: true,
      usageDesc: "getAuthResponseToken"
    })) == null ? void 0 : _a.search;
    const params = new URLSearchParams(search);
    return params.get("authResponse") ?? "";
  }
  isSignInPending() {
    try {
      const isProtocolEcho = protocolEchoReplyDetection();
      if (isProtocolEcho) {
        Logger.info("protocolEchoReply detected from isSignInPending call, the page is about to redirect.");
        return true;
      }
    } catch (error) {
      Logger.error(`Error checking for protocol echo reply isSignInPending: ${error}`);
    }
    return !!this.getAuthResponseToken();
  }
  isUserSignedIn() {
    return !!this.store.getSessionData().userData;
  }
  async handlePendingSignIn(authResponseToken = this.getAuthResponseToken(), fetchFn = createFetchFn()) {
    const sessionData = this.store.getSessionData();
    if (sessionData.userData) {
      throw new LoginFailedError("Existing user session found.");
    }
    const transitKey = this.store.getSessionData().transitKey;
    let coreNode = this.appConfig && this.appConfig.coreNode;
    if (!coreNode) {
      const network = new StacksMainnet();
      coreNode = network.bnsLookupUrl;
    }
    const tokenPayload = (0, import_jsontokens5.decodeToken)(authResponseToken).payload;
    if (typeof tokenPayload === "string") {
      throw new Error("Unexpected token payload type of string");
    }
    const isValid = await verifyAuthResponse(authResponseToken);
    if (!isValid) {
      throw new LoginFailedError("Invalid authentication response.");
    }
    let appPrivateKey = tokenPayload.private_key;
    let coreSessionToken = tokenPayload.core_token;
    if (isLaterVersion(tokenPayload.version, "1.1.0")) {
      if (transitKey !== void 0 && transitKey != null) {
        if (tokenPayload.private_key !== void 0 && tokenPayload.private_key !== null) {
          try {
            appPrivateKey = await decryptPrivateKey(transitKey, tokenPayload.private_key);
          } catch (e) {
            Logger.warn("Failed decryption of appPrivateKey, will try to use as given");
            if (!isValidPrivateKey(tokenPayload.private_key)) {
              throw new LoginFailedError("Failed decrypting appPrivateKey. Usually means that the transit key has changed during login.");
            }
          }
        }
        if (coreSessionToken !== void 0 && coreSessionToken !== null) {
          try {
            coreSessionToken = await decryptPrivateKey(transitKey, coreSessionToken);
          } catch (e) {
            Logger.info("Failed decryption of coreSessionToken, will try to use as given");
          }
        }
      } else {
        throw new LoginFailedError("Authenticating with protocol > 1.1.0 requires transit key, and none found.");
      }
    }
    let hubUrl = BLOCKSTACK_DEFAULT_GAIA_HUB_URL;
    let gaiaAssociationToken;
    if (isLaterVersion(tokenPayload.version, "1.2.0") && tokenPayload.hubUrl !== null && tokenPayload.hubUrl !== void 0) {
      hubUrl = tokenPayload.hubUrl;
    }
    if (isLaterVersion(tokenPayload.version, "1.3.0") && tokenPayload.associationToken !== null && tokenPayload.associationToken !== void 0) {
      gaiaAssociationToken = tokenPayload.associationToken;
    }
    const userData = {
      profile: tokenPayload.profile,
      email: tokenPayload.email,
      decentralizedID: tokenPayload.iss,
      identityAddress: getAddressFromDID(tokenPayload.iss),
      appPrivateKey,
      coreSessionToken,
      authResponseToken,
      hubUrl,
      appPrivateKeyFromWalletSalt: tokenPayload.appPrivateKeyFromWalletSalt,
      coreNode: tokenPayload.blockstackAPIUrl,
      gaiaAssociationToken
    };
    const profileURL = tokenPayload.profile_url;
    if (!userData.profile && profileURL) {
      const response = await fetchFn(profileURL);
      if (!response.ok) {
        userData.profile = Object.assign({}, DEFAULT_PROFILE);
      } else {
        const responseText = await response.text();
        const wrappedProfile = JSON.parse(responseText);
        userData.profile = extractProfile(wrappedProfile[0].token);
      }
    } else {
      userData.profile = tokenPayload.profile;
    }
    sessionData.userData = userData;
    this.store.setSessionData(sessionData);
    return userData;
  }
  loadUserData() {
    const userData = this.store.getSessionData().userData;
    if (!userData) {
      throw new InvalidStateError("No user data found. Did the user sign in?");
    }
    return userData;
  }
  encryptContent(content, options) {
    const opts = Object.assign({}, options);
    if (!opts.privateKey) {
      opts.privateKey = this.loadUserData().appPrivateKey;
    }
    return encryptContent(content, opts);
  }
  decryptContent(content, options) {
    const opts = Object.assign({}, options);
    if (!opts.privateKey) {
      opts.privateKey = this.loadUserData().appPrivateKey;
    }
    return decryptContent(content, opts);
  }
  signUserOut(redirectURL) {
    this.store.deleteSessionData();
    if (redirectURL) {
      if (typeof location !== "undefined" && location.href) {
        location.href = redirectURL;
      }
    }
  }
};
UserSession.prototype.makeAuthRequest = UserSession.prototype.makeAuthRequestToken;

// node_modules/@stacks/auth/dist/esm/profile.js
function lookupProfile(lookupOptions) {
  if (!lookupOptions.username) {
    return Promise.reject(new Error("No username provided"));
  }
  const defaultOptions = {
    network: new StacksMainnet()
  };
  const options = Object.assign(defaultOptions, lookupOptions);
  const network = StacksNetwork.fromNameOrNetwork(options.network);
  let lookupPromise;
  if (options.zoneFileLookupURL) {
    const url = `${options.zoneFileLookupURL.replace(/\/$/, "")}/${options.username}`;
    lookupPromise = network.fetchFn(url).then((response) => response.json());
  } else {
    lookupPromise = network.getNameInfo(options.username);
  }
  return lookupPromise.then((responseJSON) => {
    if (responseJSON.hasOwnProperty("zonefile") && responseJSON.hasOwnProperty("address")) {
      return resolveZoneFileToProfile(responseJSON.zonefile, responseJSON.address, network.fetchFn);
    } else {
      throw new Error("Invalid zonefile lookup response: did not contain `address` or `zonefile` field");
    }
  });
}

// node_modules/@stacks/connect/dist/index.mjs
var import_jsontokens6 = __toESM(require_lib3(), 1);

// node_modules/@stacks/connect-ui/dist/esm/loader.js
var patchEsm = () => {
  return promiseResolve();
};
var defineCustomElements = (win, options) => {
  if (typeof window === "undefined")
    return Promise.resolve();
  return patchEsm().then(() => {
    return bootstrapLazy([["connect-modal", [[1, "connect-modal", { "authOptions": [16], "hasOpenedInstall": [32], "hasOpenedInstallXverse": [32] }]]]], options);
  });
};

// node_modules/@stacks/connect-ui/loader/index.js
(function() {
  if ("undefined" !== typeof window && void 0 !== window.Reflect && void 0 !== window.customElements) {
    var a2 = HTMLElement;
    window.HTMLElement = function() {
      return Reflect.construct(a2, [], this.constructor);
    };
    HTMLElement.prototype = a2.prototype;
    HTMLElement.prototype.constructor = HTMLElement;
    Object.setPrototypeOf(HTMLElement, a2);
  }
})();

// node_modules/@stacks/connect/dist/index.mjs
var X = Object.defineProperty;
var M = Object.defineProperties;
var L = Object.getOwnPropertyDescriptors;
var T = Object.getOwnPropertySymbols;
var D = Object.prototype.hasOwnProperty;
var R = Object.prototype.propertyIsEnumerable;
var b = (e, t, n) => t in e ? X(e, t, { enumerable: true, configurable: true, writable: true, value: n }) : e[t] = n;
var a = (e, t) => {
  for (var n in t || (t = {}))
    D.call(t, n) && b(e, n, t[n]);
  if (T)
    for (var n of T(t))
      R.call(t, n) && b(e, n, t[n]);
  return e;
};
var c = (e, t) => M(e, L(t));
var f = (e, t) => {
  var n = {};
  for (var r in e)
    D.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && T)
    for (var r of T(e))
      t.indexOf(r) < 0 && R.call(e, r) && (n[r] = e[r]);
  return n;
};
function d() {
  return window.StacksProvider || window.BlockstackProvider;
}
function zt() {
  return !!d();
}
var Ht = "https://app.blockstack.org";
var B = "7.4.0";
typeof window != "undefined" && (window.__CONNECT_VERSION__ = B);
var z = () => {
  let e = navigator.userAgent;
  return /android/i.test(e) || /iPad|iPhone|iPod/.test(e) ? true : /windows phone/i.test(e);
};
var Qt = () => !z();
var U = (e) => {
  if (!e) {
    let t = new AppConfig(["store_write"], document.location.href);
    e = new UserSession({ appConfig: t });
  }
  return e;
};
var A = async (e, t = d()) => {
  if (!t)
    throw new Error("[Connect] No installed Stacks wallet found");
  let { redirectTo: n = "/", manifestPath: r, onFinish: s, onCancel: o, sendToSignIn: i = false, userSession: p, appDetails: u } = e, l = U(p);
  l.isUserSignedIn() && l.signUserOut();
  let S = l.generateAndStoreTransitKey(), F = l.makeAuthRequest(S, `${document.location.origin}${n}`, `${document.location.origin}${r}`, l.appConfig.scopes, void 0, void 0, { sendToSignIn: i, appDetails: u, connectVersion: B });
  try {
    let P = await t.authenticationRequest(F);
    await l.handlePendingSignIn(P);
    let h = (0, import_jsontokens6.decodeToken)(P), $ = h == null ? void 0 : h.payload;
    s == null || s({ authResponse: P, authResponsePayload: $, userSession: l });
  } catch (P) {
    console.error("[Connect] Error during auth request", P), o == null || o();
  }
};
var Zt = async (e) => (e = U(e), e.isUserSignedIn() ? e.loadUserData() : e.isSignInPending() ? e.handlePendingSignIn() : null);
var Y = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function m(e) {
  if (!(e instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let t = "";
  for (let n of e)
    t += Y[n];
  return t;
}
function I(e) {
  if (typeof e != "string")
    throw new TypeError(`hexToBytes: expected string, got ${typeof e}`);
  let t = e.length % 2 ? `0${e}` : e, n = new Uint8Array(t.length / 2);
  for (let r = 0; r < n.length; r++) {
    let s = r * 2, o = t.slice(s, s + 2), i = Number.parseInt(o, 16);
    if (Number.isNaN(i) || i < 0)
      throw new Error("Invalid byte sequence");
    n[r] = i;
  }
  return n;
}
var G = ((r) => (r.ContractCall = "contract_call", r.ContractDeploy = "smart_contract", r.STXTransfer = "token_transfer", r))(G || {});
var W = ((o) => (o.BUFFER = "buffer", o.UINT = "uint", o.INT = "int", o.PRINCIPAL = "principal", o.BOOL = "bool", o))(W || {});
var x = (e) => {
  let t = e;
  if (!t) {
    let n = new AppConfig(["store_write"], document.location.href);
    t = new UserSession({ appConfig: n });
  }
  return t;
};
function g(e) {
  try {
    return x(e).loadUserData().appPrivateKey;
  } catch (t) {
    return false;
  }
}
var y = (e) => {
  let n = x(e).loadUserData().appPrivateKey, r = import_jsontokens6.SECP256K1Client.derivePublicKey(n);
  return { privateKey: n, publicKey: r };
};
function st(e) {
  var p;
  let { stxAddress: t, userSession: n, network: r } = e;
  if (t)
    return t;
  if (!n || !r)
    return;
  let s = (p = n == null ? void 0 : n.loadUserData().profile) == null ? void 0 : p.stxAddress, o = { [ChainID.Mainnet]: "mainnet", [ChainID.Testnet]: "testnet" };
  return s == null ? void 0 : s[o[r.chainId]];
}
function at(e) {
  let t = e.network || new StacksTestnet(), n = x(e.userSession), r = c(a({}, e), { network: t, userSession: n });
  return a({ stxAddress: st(r) }, r);
}
function E(e) {
  return e.map((t) => m(serializePostCondition(t)));
}
async function C(e, t) {
  let { postConditions: n } = e;
  return n && typeof n[0] != "string" && (n = E(n)), new import_jsontokens6.TokenSigner("ES256k", t).signAsync(c(a({}, e), { postConditions: n }));
}
function w(e) {
  let { postConditions: t } = e;
  return t && typeof t[0] != "string" && (t = E(t)), (0, import_jsontokens6.createUnsecuredToken)(c(a({}, e), { postConditions: t }));
}
var it = async ({ token: e, options: t }, n) => {
  var r, s, o;
  try {
    let i = await n.transactionRequest(e), { txRaw: p } = i, u = I(p.replace(/^0x/, "")), l = deserializeTransaction(u);
    if ("sponsored" in t && t.sponsored) {
      (r = t.onFinish) == null || r.call(t, c(a({}, i), { stacksTransaction: l }));
      return;
    }
    (s = t.onFinish) == null || s.call(t, c(a({}, i), { stacksTransaction: l }));
  } catch (i) {
    console.error("[Connect] Error during transaction request", i), (o = t.onCancel) == null || o.call(t);
  }
};
var ct = async (e) => {
  let p = e, { functionArgs: t, appDetails: n, userSession: r } = p, s = f(p, ["functionArgs", "appDetails", "userSession"]), o = t.map((u) => typeof u == "string" ? u : m(serializeCV(u)));
  if (g(r)) {
    let { privateKey: u, publicKey: l } = y(r), S = c(a({}, s), { functionArgs: o, txType: "contract_call", publicKey: l });
    return n && (S.appDetails = n), C(S, u);
  }
  let i = c(a({}, s), { functionArgs: o, txType: "contract_call" });
  return n && (i.appDetails = n), w(i);
};
var pt = async (e) => {
  let o = e, { appDetails: t, userSession: n } = o, r = f(o, ["appDetails", "userSession"]);
  if (g(n)) {
    let { privateKey: i, publicKey: p } = y(n), u = c(a({}, r), { publicKey: p, txType: "smart_contract" });
    return t && (u.appDetails = t), C(u, i);
  }
  let s = c(a({}, r), { txType: "smart_contract" });
  return t && (s.appDetails = t), w(s);
};
var ut = async (e) => {
  let i = e, { amount: t, appDetails: n, userSession: r } = i, s = f(i, ["amount", "appDetails", "userSession"]);
  if (g(r)) {
    let { privateKey: p, publicKey: u } = y(r), l = c(a({}, s), { amount: t.toString(10), publicKey: u, txType: "token_transfer" });
    return n && (l.appDetails = n), C(l, p);
  }
  let o = c(a({}, s), { amount: t.toString(10), txType: "token_transfer" });
  return n && (o.appDetails = n), w(o);
};
async function k(e, t, n) {
  let r = await t(a(a({}, at(e)), e));
  return it({ token: r, options: e }, n);
}
function le(e, t = d()) {
  if (!t)
    throw new Error("[Connect] No installed Stacks wallet found");
  return k(e, ct, t);
}
function de(e, t = d()) {
  if (!t)
    throw new Error("[Connect] No installed Stacks wallet found");
  return k(e, pt, t);
}
function fe(e, t = d()) {
  if (!t)
    throw new Error("[Connect] No installed Stacks wallet found");
  return k(e, ut, t);
}
async function gt(e, t) {
  return new import_jsontokens6.TokenSigner("ES256k", t).signAsync(a({}, e));
}
function yt(e) {
  let t = e.network || new StacksTestnet(), n = x(e.userSession), r = c(a({}, e), { network: t, userSession: n });
  return a({}, r);
}
async function xt({ token: e, options: t }, n) {
  var r, s;
  if (!n)
    throw new Error("[Connect] No installed Stacks wallet found");
  try {
    let o = await n.psbtRequest(e);
    (r = t.onFinish) == null || r.call(t, o);
  } catch (o) {
    console.error("[Connect] Error during psbt request", o), (s = t.onCancel) == null || s.call(t);
  }
}
var St = async (e) => {
  let p = e, { allowedSighash: t, hex: n, signAtIndex: r, userSession: s } = p, o = f(p, ["allowedSighash", "hex", "signAtIndex", "userSession"]);
  if (g(s)) {
    let { privateKey: u, publicKey: l } = y(s), S = c(a({}, o), { allowedSighash: t, hex: n, signAtIndex: r, publicKey: l });
    return gt(S, u);
  }
  let i = a({}, o);
  return (0, import_jsontokens6.createUnsecuredToken)(i);
};
async function mt(e, t, n) {
  let r = await t(a(a({}, yt(e)), e));
  return xt({ token: r, options: e }, n);
}
function he(e, t = d()) {
  return mt(e, St, t);
}
function Ct(e) {
  var i;
  let { userSession: t, network: n } = e;
  if (!t || !n)
    return;
  let r = (i = t == null ? void 0 : t.loadUserData().profile) == null ? void 0 : i.stxAddress, s = { [ChainID.Mainnet]: "mainnet", [ChainID.Testnet]: "testnet" };
  return r == null ? void 0 : r[s[n.chainId]];
}
async function wt(e, t) {
  return new import_jsontokens6.TokenSigner("ES256k", t).signAsync(a({}, e));
}
function O(e) {
  let t = e.network || new StacksTestnet(), n = x(e.userSession), r = c(a({}, e), { network: t, userSession: n });
  return a({ stxAddress: Ct(r) }, r);
}
async function kt({ token: e, options: t }, n) {
  var r, s;
  try {
    let o = await n.signatureRequest(e);
    (r = t.onFinish) == null || r.call(t, o);
  } catch (o) {
    console.error("[Connect] Error during signature request", o), (s = t.onCancel) == null || s.call(t);
  }
}
var Ot = async (e) => {
  let s = e, { userSession: t } = s, n = f(s, ["userSession"]);
  if (g(t)) {
    let { privateKey: o, publicKey: i } = y(t), p = c(a({}, n), { publicKey: i });
    return wt(p, o);
  }
  let r = a({}, n);
  return (0, import_jsontokens6.createUnsecuredToken)(r);
};
async function bt(e, t, n) {
  let r = await t(a(a({}, O(e)), e));
  return kt({ token: r, options: e }, n);
}
function Be(e, t = d()) {
  if (!t)
    throw new Error("[Connect] No installed Stacks wallet found");
  return bt(e, Ot, t);
}
async function Bt(e, t, n) {
  let r = await t(a(a({}, O(e)), e));
  return It({ token: r, options: e }, n);
}
function N(e) {
  return c(a({}, e), { message: m(serializeCV(e.message)), domain: m(serializeCV(e.domain)) });
}
async function Ut(e, t) {
  return new import_jsontokens6.TokenSigner("ES256k", t).signAsync(N(e));
}
async function At(e) {
  let r = e, { userSession: t } = r, n = f(r, ["userSession"]);
  if (g(t)) {
    let { privateKey: s, publicKey: o } = y(t), i = c(a({}, n), { publicKey: o });
    return Ut(i, s);
  }
  return (0, import_jsontokens6.createUnsecuredToken)(N(e));
}
async function It({ token: e, options: t }, n) {
  var r, s;
  try {
    let o = await n.structuredDataSignatureRequest(e);
    (r = t.onFinish) == null || r.call(t, o);
  } catch (o) {
    console.error("[Connect] Error during signature request", o), (s = t.onCancel) == null || s.call(t);
  }
}
function Fe(e, t = d()) {
  if (!t)
    throw new Error("[Connect] No installed Stacks wallet found");
  return Bt(e, At, t);
}
async function Kt(e, t) {
  return new import_jsontokens6.TokenSigner("ES256k", t).signAsync(a({}, e));
}
function Nt(e) {
  let t = e.network || new StacksTestnet(), n = x(e.userSession), r = c(a({}, e), { network: t, userSession: n });
  return a({}, r);
}
async function Ft({ token: e, options: t }, n) {
  var r, s;
  try {
    let o = await n.profileUpdateRequest(e);
    (r = t.onFinish) == null || r.call(t, o);
  } catch (o) {
    console.error("[Connect] Error during signature request", o), (s = t.onCancel) == null || s.call(t);
  }
}
var $t = async (e) => {
  let o = e, { userSession: t, profile: n } = o, r = f(o, ["userSession", "profile"]);
  if (g(t)) {
    let { privateKey: i, publicKey: p } = y(t), u = c(a({}, r), { profile: n, publicKey: p });
    return Kt(u, i);
  }
  let s = a({}, r);
  return (0, import_jsontokens6.createUnsecuredToken)(s);
};
async function Xt(e, t, n) {
  let r = await t(a(a({}, Nt(e)), e));
  return Ft({ token: r, options: e }, n);
}
function ze(e, t = d()) {
  if (!t)
    throw new Error("[Connect] No installed Stacks wallet found");
  return Xt(e, $t, t);
}
var Mt = ((o) => (o[o.DEFAULT = 0] = "DEFAULT", o[o.ALL = 1] = "ALL", o[o.NONE = 2] = "NONE", o[o.SINGLE = 3] = "SINGLE", o[o.ANYONECANPAY = 128] = "ANYONECANPAY", o))(Mt || {});
var _t = (e, t = d()) => {
  if (t) {
    A(e, t);
    return;
  }
  if (typeof window !== void 0) {
    defineCustomElements(window);
    let n = document.createElement("connect-modal");
    n.authOptions = e, document.body.appendChild(n);
    let r = (s) => {
      s.key === "Escape" && (document.removeEventListener("keydown", r), n.remove());
    };
    document.addEventListener("keydown", r);
  }
};
var Ze = (e) => _t(e);

export {
  BLOCKSTACK_HANDLER2 as BLOCKSTACK_HANDLER,
  BLOCKSTACK_STORAGE_LABEL,
  DEFAULT_BLOCKSTACK_HOST,
  DEFAULT_PROFILE,
  DEFAULT_SCOPE,
  BLOCKSTACK_APP_PRIVATE_KEY_LABEL,
  DEFAULT_CORE_NODE,
  NAME_LOOKUP_PATH,
  LOCALSTORAGE_SESSION_KEY,
  AppConfig,
  makeDIDFromAddress,
  makeDIDFromPublicKey,
  getDIDType,
  getAddressFromDID,
  makeAuthRequest,
  makeAuthRequestToken,
  decryptPrivateKey,
  makeAuthResponse,
  getAuthRequestFromURL,
  fetchAppManifest,
  doSignaturesMatchPublicKeys,
  doPublicKeysMatchIssuer,
  isIssuanceDateValid,
  isExpirationDateValid,
  isManifestUriValid,
  isRedirectUriValid,
  verifyAuthRequest,
  verifyAuthRequestAndLoadManifest,
  verifyAuthResponse,
  UserSession,
  lookupProfile,
  d,
  zt,
  Ht,
  z,
  Qt,
  U,
  A,
  Zt,
  G,
  W,
  x,
  g,
  y,
  st,
  ct,
  pt,
  ut,
  le,
  de,
  fe,
  yt,
  St,
  he,
  O,
  Ot,
  Be,
  At,
  Fe,
  Nt,
  $t,
  ze,
  Mt,
  _t,
  Ze
};
/*! Bundled license information:

@scure/base/lib/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip39/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@noble/secp256k1/lib/index.js:
  (*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=chunk-MVRJ52EJ.js.map
